<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>指针终结者</title>
    <url>/2021/12/05/%E6%8C%87%E9%92%88%E7%BB%88%E7%BB%93%E8%80%85/</url>
    <content><![CDATA[<h1 id="指针是什么"><a href="#指针是什么" class="headerlink" title="指针是什么"></a>指针是什么</h1><blockquote>
<p>在计算机科学中，指针是编译程序中的一个对象，利用地址，它的值直接指向存在电脑存储器中另一个地方的值，由于通过地址找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化称为”指针”。<u>意思是通过它能找到以它为地址大的内存单元</u></p>
</blockquote>
<span id="more"></span>

<h5 id="总的来说，指针就是一个变量，里面存着内存单元的地址-编号-，指针就是地址。（存放在指针中的值都被当成变量来处理）。"><a href="#总的来说，指针就是一个变量，里面存着内存单元的地址-编号-，指针就是地址。（存放在指针中的值都被当成变量来处理）。" class="headerlink" title="总的来说，指针就是一个变量，里面存着内存单元的地址(编号)，指针就是地址。（存放在指针中的值都被当成变量来处理）。"></a>总的来说，指针就是一个变量，里面存着内存单元的地址(编号)，指针就是地址。（存放在指针中的值都被当成变量来处理）。</h5><h5 id="那么问题是："><a href="#那么问题是：" class="headerlink" title="那么问题是："></a>那么问题是：</h5><ul>
<li>一个内存单元有多大？(一个字节)</li>
<li>如何编址？</li>
</ul>
<p>一个内存单元一个字节就够了，然后不同数据类型的数据存储就按照字节由低到高排就行。比如，浮点型8个字节，它就会使用8个连续的内存单元，然后第一个内存单元就是其地址。</p>
<p>经过研究发现，一个字节给一个对应的地址是比较合适的。</p>
<p>对于32位的机器，假如有32根地址线，那么假设每根地址线在寻址的是产生一个电信号正电或者负电(1或者0)，那么32根地址线产生的地址就会是32个全0到32个全1，也就是说一共会产生$2^{32}$个地址。</p>
<h5 id="这里我们就能明白"><a href="#这里我们就能明白" class="headerlink" title="这里我们就能明白"></a>这里我们就能明白</h5><ul>
<li>在32位的操作系统中，地址是32个0或者1组成的二进制序列，那地址就得使用4个字节的空间来存储，所以一个指针变量的大小就应该是4个字节</li>
<li>在64位的操作系统中，则是8个字节。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>指针是用来存放地址的，地址是唯一标识一块地址空间的。</li>
<li>指针的大小在32位系统中是4个字节，64位系统中是8个字节。</li>
</ul>
</blockquote>
<hr>
<h1 id="指针和指针类型"><a href="#指针和指针类型" class="headerlink" title="指针和指针类型"></a>指针和指针类型</h1><blockquote>
<p>通过上述可知(以32位为例)，所有类型的指针都是4个字节，那不禁有个问题：是不是可以用一个范型的指针来代替所有的指针就可以呢？</p>
</blockquote>
<p>通过代码验证可知，不同指针类型可以进行对指针的存储，但是会警告。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">int</span>* pa = &amp;a;</span><br><span class="line">*pa = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这个是运行结果是，a所有字节的值都变成了0，也就是44 33 22 11 变成了 00 00 00 00</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\\代码<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">int</span>* pc = &amp;a;</span><br><span class="line">*pc = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这个运行的结果就不一样了，44 33 22 11 变成了 00 33 22 11，也就只对数据a的其中一个字节进行了赋值操作。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>指针类型决定了指针进行解引用操作的时候，能够访问空间的大小。对指针解引用时候有多大的权限(能操作几个字符)。</p>
<ul>
<li>int* p; *p能够访问4个字节</li>
<li>char* p; *p能够访问1个字节</li>
<li>double* p; *p能够访问8个字节</li>
</ul>
</blockquote>
<h3 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针+-整数"></a>指针+-整数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;n;</span><br><span class="line"><span class="keyword">int</span>* pi = &amp;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>通过对代码的运行，我们可知，主要是地址的后两位的变化。pc的后两位是58，而pc+1则是59。对于pi来说，它的地址也是58，但是pi+1的结果则是5C。说明pc+1就是往后移动了一个字节，但是pi+1则就是往后移动了4个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际操作：将数组的所有元素都变成1，对比输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//int *p = arr;   //数组名-首元素的地址</span></span><br><span class="line">    <span class="keyword">char</span> *p = arr;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>指针的类型决定了指针向前或者向后走一步有多大(距离)。</p>
</blockquote>
<hr>
<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><blockquote>
<p>概念：野指针就是指针指向的位置是不可知的（随机的、不确定的、没有明确限制的）</p>
</blockquote>
<h3 id="野指针形成的原因"><a href="#野指针形成的原因" class="headerlink" title="野指针形成的原因"></a>野指针形成的原因</h3><ol>
<li>指针未初始化 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">//局部变量是指针未初始化，默认为随机值</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li>
<li>指针访问越界 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>指针指向的空间被释放</li>
</ol>
<h3 id="如何避免野指针"><a href="#如何避免野指针" class="headerlink" title="如何避免野指针"></a>如何避免野指针</h3><ol>
<li>指针初始化</li>
<li>小心指针越界</li>
<li>指针指向空间释放即使置NULL</li>
<li>指针使用之前要检查有效性</li>
</ol>
<hr>
<h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><ul>
<li>指针+-正数</li>
<li>指针-指针</li>
<li>指针的关系运算</li>
</ul>
<h3 id="指针-—整数"><a href="#指针-—整数" class="headerlink" title="指针+—整数"></a>指针+—整数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_VALUES 5</span></span><br><span class="line"><span class="keyword">float</span> values[N_VALUES];</span><br><span class="line"><span class="keyword">float</span> *vp;</span><br><span class="line"><span class="keyword">for</span>(vp=&amp;values[<span class="number">0</span>]; vp&lt;values[N_VALUES];)</span><br><span class="line">&#123;</span><br><span class="line">    *vp++ = <span class="number">0</span>; <span class="comment">//这个代码执行是，先*vp=0，然后在vp++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针-指针"></a>指针-指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用头尾指针的方法，尾指针-头指针=指针之间的长度</span></span><br><span class="line">    <span class="keyword">char</span>* start = str;</span><br><span class="line">    <span class="keyword">char</span>* end = str;</span><br><span class="line">    <span class="keyword">while</span>(*end != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = my_strlen(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="标准规定"><a href="#标准规定" class="headerlink" title="标准规定"></a>标准规定</h5><blockquote>
<p>允许指向数组元素的指针指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</p>
</blockquote>
<hr>
<h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><p>数组名是什么？我们看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr)</span><br></pre></td></tr></table></figure>
<p>我们会发现得出来的结果都是一样的，但是他们的含义不一样。</p>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>&amp;arr &amp;数组名，表示取出来的是整个数组的地址。</li>
<li>sizeof(arr)，计算的是整个数组的大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>00EFF8E0</td>
</tr>
<tr>
<td>arr+1</td>
<td>00EFF8E4</td>
</tr>
<tr>
<td>&amp;arr[0]</td>
<td>00EFF8E0</td>
</tr>
<tr>
<td>&amp;arr[0]+1</td>
<td>00EFF8E4</td>
</tr>
<tr>
<td>&amp;arr</td>
<td>00EFF8E0</td>
</tr>
<tr>
<td>&amp;arr+1</td>
<td>00EFF908</td>
</tr>
</tbody></table>
<p>我们通过输出地址可以看出，前两个的+1，都是+1一个元素的大小，但是&amp;arr+1加的则是整个数组的长度。16进制的28，其10进制结果则是40，也就是整个数组的长度。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>难点</tag>
      </tags>
  </entry>
  <entry>
    <title>sklearn决策树</title>
    <url>/2021/12/28/sklearn%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="决策树-descision-tree-分类树"><a href="#决策树-descision-tree-分类树" class="headerlink" title="决策树(descision tree)(分类树)"></a>决策树(descision tree)(分类树)</h1><h2 id="1-决策树的基本概念"><a href="#1-决策树的基本概念" class="headerlink" title="1.决策树的基本概念"></a>1.决策树的基本概念</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>决策树是一种基本的分类于回归方法，在分类问题中，表示基于特征对实例进行分类的过程。</p>
<h3 id="1-2-决策树的三个基本步骤"><a href="#1-2-决策树的三个基本步骤" class="headerlink" title="1.2 决策树的三个基本步骤"></a>1.2 决策树的三个基本步骤</h3><ul>
<li>特征选择</li>
<li>决策树的生成</li>
<li>决策树的修剪</li>
</ul>
<h3 id="1-3-用决策树分类"><a href="#1-3-用决策树分类" class="headerlink" title="1.3 用决策树分类"></a>1.3 用决策树分类</h3><p>从<strong>根节点</strong>开始，对实例的某一特征进行测试，根据测试结果将实例分配到其<strong>子节点</strong>，此时每一个子节点对应着该特征的一个取值，如此递归对实例进行测试并分配，直到到达<strong>叶节点</strong>，最后将实例分到<strong>叶节点</strong>的类中。</p>
<span id="more"></span>

<p><img src="/.io//sklearn%E5%86%B3%E7%AD%96%E6%A0%91%5C%E5%86%B3%E7%AD%96%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<p>其中圆点是<strong>内部节点</strong>，方框是<strong>叶节点</strong></p>
<p><strong>关键概念：结点</strong></p>
<ol>
<li>根节点：没有进边，有出边，包含最初的，针对特征问题提问</li>
<li>中间节点：即有进边也有出边，进边只有一条，出边可以有很多条，都是针对特征问题提问</li>
<li>叶子节点：有进边，没有出边，<strong>每一个叶子节点都是一个类别的标签</strong></li>
</ol>
<h3 id="1-4-决策树的其他信息"><a href="#1-4-决策树的其他信息" class="headerlink" title="1.4 决策树的其他信息"></a>1.4 决策树的其他信息</h3><ul>
<li>决策树学习的目标：根据训练数据构成一个模型，然后对未知数据能够进行合理的分类</li>
<li>决策树的本质：从训练集中归纳出一组分类规则，或者说是由训练数据集估计<strong>条件概率模型</strong></li>
<li>决策树学习的损失函数：正则化的极大似然函数</li>
<li>决策树学习的测试：最小化损失函数</li>
<li>决策树学习的目标：在损失函数的意义下，选择最优决策树的问题</li>
<li>决策树原理和问答猜测结果游戏相似，根据一系列数据，然后给出游戏的答案。(就是一直问问题)</li>
</ul>
<h3 id="1-5-决策树算法核心问题"><a href="#1-5-决策树算法核心问题" class="headerlink" title="1.5 决策树算法核心问题"></a>1.5 决策树算法核心问题</h3><ol>
<li>如何从数据表中找出最佳节点和最佳分枝？</li>
<li>如何让决策树停止生长，防止过拟合？</li>
</ol>
<h2 id="2-决策树的构造"><a href="#2-决策树的构造" class="headerlink" title="2. 决策树的构造"></a>2. 决策树的构造</h2><h4 id="2-1-决策树构造步骤"><a href="#2-1-决策树构造步骤" class="headerlink" title="2.1 决策树构造步骤"></a>2.1 决策树构造步骤</h4><p>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类的过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。</p>
<ol>
<li>构建根节点，将所有的训练数据都放在根节点，选择一个最优特征，按着这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下最好的分类</li>
<li>如果这些子集能够基本被正确分类，那么构建叶节点，并将这些子集分到对应的叶节点去。</li>
<li>如过还有子集不能够被正确的分类，那么就对这些子集重新选最优特征，继续对其进行分割，构建相应的节点，如果递归进行，知道所有训练数据子集基本正确的分类，或者没有合适的特征为止。</li>
<li>每个子集都分到叶节点上，即都有了明确的类，这样就生成了一个决策树。</li>
</ol>
<h3 id="2-2-决策树的特点"><a href="#2-2-决策树的特点" class="headerlink" title="2.2 决策树的特点"></a>2.2 决策树的特点</h3><ul>
<li>优点：计算复杂程度不高，输出结果好理解，<strong>中间值缺失不敏感</strong>，可以处理不相关特征数据。</li>
<li>缺点：可能会产生过度匹配的问题。</li>
<li>使用数据类型：数值型和标签型。</li>
</ul>
<blockquote>
<p>首先：确定当前数据集上的决定性特征，为了得到该决定性特征，必须评估每个特征，完成测试之后，原始数据集就被划分为几个数据子集，这些数据子集会分布在第一个决策点的所有分支上，如果某个分支下的数据属于同一类型，则当前无需阅读的垃圾邮件已经正确的划分数据分类，无需进一步对数据集进行分割，如果不属于同一类，则要重复划分数据子集，直到所有相同类型的数据均在一个数据子集内。</p>
<p><img src="/.io//sklearn%E5%86%B3%E7%AD%96%E6%A0%91%5C%E5%86%B3%E7%AD%96%E6%A0%91%E9%82%AE%E7%AE%B1%E9%97%AE%E9%A2%98.jpg"></p>
</blockquote>
<h3 id="2-3-决策树伪代码"><a href="#2-3-决策树伪代码" class="headerlink" title="2.3 决策树伪代码"></a>2.3 决策树伪代码</h3><p>创建分支的伪代码createBranch()</p>
<p>检测数据集中每一个子项是否属于同一类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> so <span class="keyword">return</span> 类标签</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	寻找划分数据集的最好特征</span><br><span class="line">    划分数据集</span><br><span class="line">    创建分支节点</span><br><span class="line">    	<span class="keyword">for</span> 每个划分的子集</span><br><span class="line">        	调用createBranch()并且返回结果到分支节点中</span><br><span class="line">        <span class="keyword">return</span> 分支节点</span><br></pre></td></tr></table></figure>



<h3 id="2-4-信息增益"><a href="#2-4-信息增益" class="headerlink" title="2.4 信息增益"></a>2.4 信息增益</h3><h4 id="2-4-1-简单概述"><a href="#2-4-1-简单概述" class="headerlink" title="2.4.1 简单概述"></a>2.4.1 简单概述</h4><p>划分数据集的大原则是：将无序数据变得更加有序，信息论是量化处理信息得分支科学，在划分数据集前后信息发生得变化称为<strong>信息增益</strong>，<strong>获得信息增益最高的特征就是最好的选择</strong>，集合信息的度量方式称为：<strong>香农熵</strong>，或者简称为<strong>熵</strong>。</p>
<h4 id="2-4-2-结合实例"><a href="#2-4-2-结合实例" class="headerlink" title="2.4.2 结合实例"></a>2.4.2 结合实例</h4><p>希望通过所给的训练数据学习一个贷款申请的决策树，用以对未来的贷款申请进行分类，即当新的客户提出贷款申请时，根据申请人的特征利用决策树决定是否批准贷款申请。</p>
<p><strong>特征选择就是决定用哪个特征来划分特征空间</strong>。</p>
<p><img src="/.io//sklearn%E5%86%B3%E7%AD%96%E6%A0%91%5C%E5%86%B3%E7%AD%96%E6%A0%91%E8%B4%B7%E6%AC%BE%E7%94%B3%E8%AF%B7.jpg"></p>
<p>第一个图的根节点的特征是年龄，有3个取值，不同的取值有不同的节点。第二个图的根节点的特征是工作，有2个取值，不同的取值有不同的节点。两个决策树都可以延续下去，但是，我们应该选取那一个特征更好一些呢？一般来说，如果一个特征具有更好的分类能力，或者说，按照这个特征将数据集分割的子集，使得各个子集在当前条件下有最好的分类，那么就更应该选择这个特征。</p>
<h4 id="2-4-3-信息增益和经验熵"><a href="#2-4-3-信息增益和经验熵" class="headerlink" title="2.4.3 信息增益和经验熵"></a>2.4.3 信息增益和经验熵</h4><p><strong>什么是信息增益？</strong>在划分数据集之前之后信息发生的变化成为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最<strong>高</strong>的特征就是最好的选择。</p>
<p><strong>熵定义为信息的期望</strong>，在待分类的事物可能划分在多个类中，则$x_{i}$的信息定义为：<br>$$<br>l(x_{i})=-log_{2}p(x_i)<br>$$<br>其中$p(x_{i})$是该分类的概率。</p>
<p>为了计算熵，我们需要计算所有类别所有可能值所包含的信息期望值，通过下式得到：<br>$$<br>H=-\sum_{i=1}^{n}p(x_{i})log_{2}p(x_{i})<br>$$<br>其中n是分类的数目，n为分类数目，熵越大，随机变量的不确定性就越大。</p>
<p>当熵中的概率是由数据计算的时候，我们就称为经验熵。数据计算就是比如有10个数据，一共有两个类别，A类和B类。其中有7个数据属于A类，则该A类的概率即为十分之七。其中有3个数据属于B类，则该B类的概率即为十分之三。浅显的解释就是，这概率是我们根据数据数出来的。我们定义贷款申请样本数据表中的数据为训练数据集D，则训练数据集D的经验熵为H(D)，|D|表示其样本容量，及样本个数。假设共有k个类$C_{k}, k=1,2,3..,k，|C_{k}|$为属于类$C_{k}$的样本个数，所以经验熵公式可以写为：<br>$$<br>H(D)=-\sum_{k=1}^{K}\frac{|C_{k}|}{|D|}log_{2}\frac{|C_{k}|}{|D|}<br>$$<br>根据此公式计算经验熵H(D)，分析贷款申请样本数据表中的数据。最终分类结果只有两类，即放贷和不放贷。根据表中的数据统计可知，在15个数据中，9个数据的结果为放贷，6个数据的结果为不放贷。所以数据集D的经验熵H(D)为：<br>$$<br>H(D)=-\frac{9}{15}log_{2}\frac{9}{15}-\frac{6}{15}log_{2}\frac{6}{15}=0.971<br>$$<br>所以，经计算可知，数据集D的经验熵H(D)为0.971</p>
<h4 id="2-4-4-信息增益和条件熵"><a href="#2-4-4-信息增益和条件熵" class="headerlink" title="2.4.4 信息增益和条件熵"></a>2.4.4 信息增益和条件熵</h4><p>信息增益表示得知特征X的信息而使得类Y的信息不确定性减少的程度。</p>
<p>条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，定义X给定条件下Y的条件概率分布的熵对X的数学期望：<br>$$<br>H(Y|X)=\sum_{i=1}^{n}p_{i}H(Y|X=x_{i})<br>$$<br>其中，$p_{i}=p(X=x_{i})$</p>
<p>当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，所对应的分别为经验熵和经验条件熵，此时如果有0概率，则令$0log0=0$</p>
<p><strong>信息增益</strong>：信息增益是相对于特征而言的。所以，特征A对训练数据集D的信息增益$g(D,A)$，定义为集合D的经验熵H(D)与特征A给定条件下集合D的经验条件熵$H(D|A)$之差，即：<br>$$<br>g(D,A)=H(D)-H(D|A)<br>$$<br>一般地，熵H(D)与条件熵H(D|A)之差成为**互信息(mutual information)**。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>信息增益值的大小相对于训练数据集而言的，并没有绝对意义，在分类问题困难时，也就是说在训练数据集经验熵大的时候，信息增益值会偏大，反之信息增益值会偏小，使用信息增益比可以对这个问题进行校正，这是特征选择的另一个标准。</p>
<p><strong>信息增益比</strong>：特征A AA对训练数据集D的信息增益比$g_{R}(D,A)$定义为其信息增益$g(D,A)$与训练数据集D关于特征A的经验熵之比：<br>$$<br>g_{R}(D,A)=\frac{g(D,A)}{H_A(D)}<br>$$</p>
<h2 id="3-sklearn中的决策树"><a href="#3-sklearn中的决策树" class="headerlink" title="3. sklearn中的决策树"></a>3. sklearn中的决策树</h2><h3 id="3-1-模块sklearn-tree"><a href="#3-1-模块sklearn-tree" class="headerlink" title="3.1 模块sklearn.tree"></a>3.1 模块sklearn.tree</h3><p>sklearn中的决策树都在<strong>tree</strong>这个模块下，这个模块包含五个类：</p>
<table>
<thead>
<tr>
<th>tree.DecisionTreeClassifier</th>
<th>分类树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>tree.DecisionTreeRegressor</strong></td>
<td><strong>回归树</strong></td>
</tr>
<tr>
<td><strong>tree.expeort_graphiz</strong></td>
<td><strong>将决策树导出为DOT格式，画图</strong></td>
</tr>
<tr>
<td><strong>tree.ExtraTreeClassifier</strong></td>
<td><strong>高版本分类树</strong></td>
</tr>
<tr>
<td><strong>tress.ExtraTreeRegressor</strong></td>
<td><strong>高版本回归树</strong></td>
</tr>
</tbody></table>
<h3 id="3-2-sklearn的基本建模流程"><a href="#3-2-sklearn的基本建模流程" class="headerlink" title="3.2 sklearn的基本建模流程"></a>3.2 sklearn的基本建模流程</h3><ol>
<li>实例化，建立评估模型对象(实例化时需要使用的参数)</li>
<li>通过模型接口训练模型(将训练样本放入其中)</li>
<li>通过模型接口提取需要的信息</li>
</ol>
<p>这个流程中，分类树对应代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入需要的模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line"><span class="comment"># 导入训练集数据，用来训练模型</span></span><br><span class="line">clf = clf.fit(x_train, y_train)</span><br><span class="line"><span class="comment"># 导入测试集数据，然后通过接口获得想要的信息</span></span><br><span class="line">result = clf.score(x_test, y_test)</span><br></pre></td></tr></table></figure>



<h3 id="3-3-重要参数"><a href="#3-3-重要参数" class="headerlink" title="3.3 重要参数"></a>3.3 重要参数</h3><h4 id="3-3-1-criterion"><a href="#3-3-1-criterion" class="headerlink" title="3.3.1 criterion"></a>3.3.1 criterion</h4><p>为了要将表格转化为一棵树，决策树要找到最佳节点和最佳的分枝方法，对分类树来说，衡量这个算法的叫做“不纯度”。通常来说，不纯度越低，决策树对训练集的拟合越好，目前使用的决策树算法在分枝上大都是围绕某个不纯度相关指标的最优化上。</p>
<p>树中的每一个节点都有一个不纯度，并且子节点的不纯度一定低于父节点的不纯度。</p>
<p>criterion这个参数决定不纯度的计算方法。sklearn提供了两种选择：</p>
<ol>
<li>输入‘entropy’，使用<strong>信息熵</strong></li>
<li>输入‘gini’，使用基尼系数</li>
</ol>
<p>$$<br>Entropy(t)=-\sum_{i=0}^{c-1}p(i|t)log_{2}p(i|t)<br>$$</p>
<p>$$<br>Gini(t)=1-\sum_{i=0}^{c-1}p(i|t)^2<br>$$</p>
<p>其中$t$代表给定的节点(上述中的数据集D)，$i$代表标签的任意分类，$P(i|t)$代表标签分类$i$在节点$t$上所占的比例。sklearn实际计算的是基于信息熵的<strong>信息增益</strong>，即是父节点的信息熵和子节点的信息熵之差。</p>
<p>信息熵对不纯度更加敏感，对不纯度的惩罚最强。但是在实际应用中，<strong>信息熵和基尼系数基本相同</strong>。信息熵涉及到了对数，所以它的计算会比基尼系数要慢一些。信息熵更敏感，所以信息熵作为指标时，决策树会更加“精细”，因此对于高维数据或者噪声很多的数据时，防止过拟合，基尼系数会比较好，但并不是绝对的。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>criterion</th>
</tr>
</thead>
<tbody><tr>
<td>如何影响模型？</td>
<td>确定不纯度的计算方法，找出最佳节点和最佳分枝，不纯度越低，决策树的拟合效果越好</td>
</tr>
<tr>
<td>可能的输入有那些？</td>
<td>不填默认基尼系数，填写gini使用基尼系数，entropy是使用信息熵</td>
</tr>
<tr>
<td>怎么样选取参数？</td>
<td>通常使用基尼系数<br>数据维度较大，噪声大用基尼系数<br>维度低，数据比较清晰，两者差不多<br>决策树拟合程度不够时，用信息熵<br>两个都试试</td>
</tr>
</tbody></table>
<h4 id="3-3-2-基本流程概括"><a href="#3-3-2-基本流程概括" class="headerlink" title="3.3.2 基本流程概括"></a>3.3.2 基本流程概括</h4><ol>
<li>计算全部特征党的不纯度指标</li>
<li>选取不纯度指标最优的特征来分枝</li>
<li>在第一个特征的分枝下，计算全部特征的不纯度</li>
<li>选取指标最优的特征继续分枝</li>
</ol>
<p>知道没有特征可用，或整体的不纯度指标已经最优，决策树就会停止生长。</p>
<h4 id="3-3-3-sklearn实例和一些问题"><a href="#3-3-3-sklearn实例和一些问题" class="headerlink" title="3.3.3 sklearn实例和一些问题"></a>3.3.3 sklearn实例和一些问题</h4><p>以sklearn中的红酒数据集为例</p>
<p><strong>数据的导入与训练</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对模块和数据的导入</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="comment"># 这个包是用来分割数据的</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">wine = load_wine()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将导入的数据合并成表</span></span><br><span class="line">pd.concat([pd.DataFrame(wine.data), pd.DataFrame(wine.target)], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意前面数据所放的位置，不要弄错</span></span><br><span class="line">Xtrain, Xtest, Ytrain, Ytest = train_test_split(wine.data, wine.target, test_size=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>)</span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)   <span class="comment"># 返回预测的准确度accuracy</span></span><br></pre></td></tr></table></figure>



<p><strong>画决策树</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">feature_names = [<span class="string">&#x27;酒精&#x27;</span>, <span class="string">&#x27;苹果酸&#x27;</span>, <span class="string">&#x27;灰&#x27;</span>, <span class="string">&#x27;灰的碱性&#x27;</span>, <span class="string">&#x27;煤&#x27;</span>, <span class="string">&#x27;总酚&#x27;</span>, <span class="string">&#x27;类黄酮&#x27;</span>, <span class="string">&#x27;非黄烷类酚类&#x27;</span>, <span class="string">&#x27;花青素&#x27;</span>, <span class="string">&#x27;颜色强度&#x27;</span></span><br><span class="line">                , <span class="string">&#x27;色调&#x27;</span>, <span class="string">&#x27;od280/od315稀释葡萄酒&#x27;</span>, <span class="string">&#x27;脯氨酸&#x27;</span>]</span><br><span class="line"></span><br><span class="line">dot_data = tree.export_graphviz(clf</span><br><span class="line">                                , feature_names = feature_names</span><br><span class="line">                                , class_names=[<span class="string">&quot;琴酒&quot;</span>, <span class="string">&quot;雪莉&quot;</span>, <span class="string">&quot;贝尔摩德&quot;</span>]</span><br><span class="line">                                , filled = <span class="literal">True</span></span><br><span class="line">                                , rounded =<span class="literal">True</span></span><br><span class="line">                                    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph</span><br></pre></td></tr></table></figure>

<p><strong>数据特征的重要程度</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf.feature_importances_</span><br><span class="line">[*<span class="built_in">zip</span>(feature_names, clf.feature_importances_)]</span><br></pre></td></tr></table></figure>



<p>我们在已经了解一个参数的情况下，建立了一个完整的决策树，但是建立模型，score会还是有波动，同样的数据，不同的训练，但是结果都不一样。他为什么这么不稳定呢？时间上是优化每一个节点，得到一个最优化的决策树，但是最优的节点一定能保证最优的树嘛？就比如，最好的种子一定能种出最好的苹果树嘛？集成算法就被用来解决这个问题：sklearn表示，既然每一棵树都不能保证最优，那就建立很多个不同的树，然后从中挑选最好的。(用很多的好种子去种树，然后把得到的树中最好的结果拿出来。)怎么样从一个数据集中建不同的树？在每次分枝的时候，不使用全部的特征，而是随机选取了一部分特征，从中选取不纯度相关指标最优的最为分枝用的节点。这样，树也就不同了。</p>
<h4 id="3-3-4-random-state-amp-splitter"><a href="#3-3-4-random-state-amp-splitter" class="headerlink" title="3.3.4 random_state &amp; splitter"></a>3.3.4 random_state &amp; splitter</h4><ul>
<li><strong>random_state</strong>是用来设置分枝中的随机模式的参数，默认为None，在高纬度时的随机性会更加的明显，低纬度数据集比如鸢尾花，而随机性几乎不会出现。输入任意一个整数，会生长出同一棵树，让模型稳定下来。</li>
<li><strong>splitter</strong>也是控制决策树中的随机项的，有两种输入值，输入“best”，决策树在分枝时，虽然随机，但是它会选择更重要的特征进行分枝(feature_importances_的结果)，输入“random”，分枝会更加的随机，树会更深，对数据的拟合程度会降低，这也是防止过拟合的方式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置一个随机数种子</span></span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>, random_state=<span class="number">0</span>)</span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)</span><br><span class="line">score</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入splitter参数</span></span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>, </span><br><span class="line">                                                    random_state=<span class="number">0</span>,</span><br><span class="line">                                                     splitter=<span class="string">&quot;random&quot;</span>)</span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)</span><br><span class="line">score</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">feature_names = [<span class="string">&#x27;酒精&#x27;</span>, <span class="string">&#x27;苹果酸&#x27;</span>, <span class="string">&#x27;灰&#x27;</span>, <span class="string">&#x27;灰的碱性&#x27;</span>, <span class="string">&#x27;煤&#x27;</span>, <span class="string">&#x27;总酚&#x27;</span>, <span class="string">&#x27;类黄酮&#x27;</span>, <span class="string">&#x27;非黄烷类酚类&#x27;</span>, <span class="string">&#x27;花青素&#x27;</span>, <span class="string">&#x27;颜色强度&#x27;</span></span><br><span class="line">                , <span class="string">&#x27;色调&#x27;</span>, <span class="string">&#x27;od280/od315稀释葡萄酒&#x27;</span>, <span class="string">&#x27;脯氨酸&#x27;</span>]</span><br><span class="line"></span><br><span class="line">dot_data = tree.export_graphviz(clf</span><br><span class="line">                                , feature_names = feature_names</span><br><span class="line">                                , class_names=[<span class="string">&quot;琴酒&quot;</span>, <span class="string">&quot;雪莉&quot;</span>, <span class="string">&quot;贝尔摩德&quot;</span>]</span><br><span class="line">                                , filled = <span class="literal">True</span></span><br><span class="line">                                , rounded =<span class="literal">True</span></span><br><span class="line">                                    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph</span><br></pre></td></tr></table></figure>



<h2 id="4-决策树的构建"><a href="#4-决策树的构建" class="headerlink" title="4. 决策树的构建"></a>4. 决策树的构建</h2><h3 id="4-1-ID3算法"><a href="#4-1-ID3算法" class="headerlink" title="4.1 ID3算法"></a>4.1 ID3算法</h3><p>ID3算法的核心是<strong>在决策各个结点上对于信息增益准则选择特征，递归构建决策树</strong>。</p>
<p>具体方法是：</p>
<ol>
<li>从根结点(root node)开始，对结点计算所有可能的特征的信息增益，选择<strong>信息增益最大</strong>的特征作为结点的特征。</li>
<li>由该特征的不同取值建立子节点，再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均<strong>很小或没有特征可以选择</strong>为止。</li>
<li>最后得到一个决策树。</li>
</ol>
<p><strong>ID3相当于用极大似然法进行概率模型的选择</strong></p>
<p><strong>算法步骤：</strong></p>
<ul>
<li>输入：训练数据集是D，特征集是A，阈值是$\varepsilon$</li>
<li>输出：决策树T</li>
<li>(1)：如果D中所有实例属于同一类$C_{k}$ ，则T为单结点树，并将类$C_{k}$ 作为该节点的类标记，返回T</li>
<li>(2)：如果A=$\emptyset$，则T为单节点树，并将D中实例树最大的类$C_{k}$ 作为该节点的类标记，返回T</li>
<li>(3)：否则计算A中的各特征对D的信息增益，选择信息增益最大的特征$A_{g}$ </li>
<li>(4)：如果$A_{k}$的信息增益小于阈值$\varepsilon$，则置T为单节点树，并将D中实例树最大的类$C_{k}$ 作为该节点的类标记，返回T</li>
<li>(5)：否则，对$A_{g}$的每一个可能取值$a_{i}$，依$A_{g}=a_{i}$将D分割为若干非空子集$D_{i}$，将$D_{i}$中实例树最大的类作为标记，构建子节点，由节点及子节点构成树T，返回T；</li>
<li>(6)：对第$i$个子节点，以$D_{i}$为训练集，以$A-A_{g}$为特征集，递归调用第(1)到第(5)步，得到子树$T_{i}$，然后返回$T_{i}$。</li>
</ul>
<h3 id="4-2-C4-5的生成算法"><a href="#4-2-C4-5的生成算法" class="headerlink" title="4.2 C4.5的生成算法"></a>4.2 C4.5的生成算法</h3><p>跟ID3相比，将信息增益比作为选择特征的标准。</p>
<h2 id="5-决策树的剪枝"><a href="#5-决策树的剪枝" class="headerlink" title="5.决策树的剪枝"></a>5.决策树的剪枝</h2><p>决策树生成算法递归的产生决策树，直到不能继续下去为止，这样产生的树往往对训练数据的分类很准确，但对未知测试数据的分类缺没有那么精确，即会出现<strong>过拟合现象</strong>。过拟合产生的原因在于在学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树，解决方法是考虑决策树的复杂度，对已经生成的树进行简化。</p>
<h3 id="5-1-基本解释"><a href="#5-1-基本解释" class="headerlink" title="5.1 基本解释"></a>5.1 基本解释</h3><p>从已经生成的树上裁掉一些子树或叶节点，并将其根节点或父节点作为新的叶子节点，从而简单分类树模型。</p>
<h3 id="5-2-实现方式"><a href="#5-2-实现方式" class="headerlink" title="5.2 实现方式"></a>5.2 实现方式</h3><p>极小化决策树整体的损失函数或代价函数来实现</p>
<p>决策树学习的损失函数定义为：<br>$$<br>C_{\alpha}(T)=\sum_{t=1}^{|T|}N_{t}H_{t}(T)+\alpha|T|<br>$$<br>其中：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>表示这棵树的叶子节点</td>
</tr>
<tr>
<td>$H_{t}(T)$</td>
<td>$H_{t}(T)=-\sum_{k}\frac{N_{tk}}{N_{t}}log\frac{N_{tk}}{N_{t}}$  <br>表示第$t$个叶子的熵</td>
</tr>
<tr>
<td>$N_{t}$</td>
<td>表示该叶子所含的训练样例的个数</td>
</tr>
<tr>
<td>$\alpha$</td>
<td>惩罚系数</td>
</tr>
</tbody></table>
<p>因为有：<br>$$<br>C(T)=\sum_{t=1}^{T}N_{t}H_{t}(T)=-\sum_{t=1}^{|T|}\sum_{k=1}^{k}N_{tk}log\frac{N_{tk}}{N_{t}}<br>$$<br>所以有：<br>$$<br>C_{\alpha}(T)=C(T)+\alpha|T|<br>$$<br>其中参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>$C(T)$</td>
<td>表示模型对训练数据的预测误差，即模型与训练数据的拟合程度。</td>
</tr>
<tr>
<td>$\alpha$</td>
<td>参数$\alpha \geq 0$控制两者之间的影响，较大的$\alpha$促使选择简单的模型(树)，较小的$\alpha$促使选择较为复制的模型(树)，$\alpha=0$意味着只考虑模型与训练数据的拟合程度，不考虑模型的复杂程度。</td>
</tr>
</tbody></table>
<p>剪枝就是当$\alpha$确定时，选择损失函数最小的模型，即损失函数最小的子树。</p>
<ul>
<li>当$\alpha$值确定时，子树越大，往往与训练数据拟合越好，但是模型的<strong>复杂度越高</strong></li>
<li>子树越小，模型的复杂程度越低，往往与训练数据的拟合不好</li>
<li>损失函数正好表示了对两者的平衡</li>
</ul>
<p>损失函数认为对于每个分类终点（叶子节点）的不确定性程度就是分类的<strong>损失因子</strong>，而叶子节点的个数是模型的<strong>复杂程度，作为惩罚项</strong>，损失函数的第一项是样本的训练误差，第二项是模型的复杂度。如果一棵子树的损失函数值越大，说明这棵子树越差，因此我们希望让每一棵子树的损失函数值尽可能得小，损失函数最小化就是用正则化的极大似然估计进行模型选择的过程。</p>
<p>决策树的剪枝过程(泛化过程)，就是从叶子节点开始<strong>递归</strong>，记其父节点将所有子节点回缩后的子树为</p>
<p>$T_{b}$(特质值比例所占最短的那个)，未回缩的子树为$T_{a}$，如果$C_{\alpha}(T_{a}) \geq C_{\alpha}(T_{b})$说明回缩后使损失函数减小了，那么这棵子树就应该回缩，递归直到无法回缩为止。可以看出，决策树的生成只是考虑通过提高信息增益对训练数据进行更好的拟合，而决策树剪枝通过优化损失函数还考虑了减小模型复杂度。</p>
<h3 id="5-3-预剪枝和后剪枝"><a href="#5-3-预剪枝和后剪枝" class="headerlink" title="5.3 预剪枝和后剪枝"></a>5.3 预剪枝和后剪枝</h3><ul>
<li><p>预剪枝是指在决策树的生成过程中，对每个节点在划分<strong>前先进行评估</strong>，若当前的划分不能带来泛化性能的提升，则停止划分，并将当前节点标记为叶节点。</p>
</li>
<li><p>后剪枝是指先从训练集生成一颗完整的决策树，然后自底向上对非叶节点进行考察，若将该节点对应的子树替换为叶节点，能带来泛化性能的提升，则将该子树替换为叶节点。</p>
</li>
<li><p>那么怎么来判断是否带来泛化性能的提升那？最简单的就是留出法，即预留一部分数据作为验证集来进行性能评估。</p>
</li>
</ul>
<h2 id="6-sklearn中的剪枝参数调优"><a href="#6-sklearn中的剪枝参数调优" class="headerlink" title="6. sklearn中的剪枝参数调优"></a>6. sklearn中的剪枝参数调优</h2><p>在不加限制的条件下，一棵决策树会生长到衡量不纯度指标最优，或者没有更多的特征可用为止，这样的决策树往往会过拟合，这就是说，<strong>它会在训练集上表现很好，在测试集上却表现不太行</strong>。我们收集的数据不可能与整体的状况完全一致，因此当一棵决策树对训练数据有了很好的解释性，也就是说它找出的规则必然包括了训练样本中的噪声，并使它对未知的数据拟合程度不足。</p>
<p>就比如说我们的树对训练集的拟合程度是1.0，但是对测试集只有的拟合程度只有80左右，<strong>说明它对训练集过拟合了，融入了噪声等</strong>。</p>
<h3 id="6-1-剪枝参数"><a href="#6-1-剪枝参数" class="headerlink" title="6.1 剪枝参数"></a>6.1 剪枝参数</h3><p>为了让决策树有更好的泛化性，我们要对决策树进行剪枝。<strong>剪枝策略对决策树的影响巨大，正确的剪枝策略是优化决策树算法的核心</strong>。</p>
<h4 id="6-1-1-max-depth"><a href="#6-1-1-max-depth" class="headerlink" title="6.1.1 max_depth"></a>6.1.1 max_depth</h4><p>限制树的最大深度，超过设点的深度的树枝全部被剪掉，在高纬度低样本量时非常有效果。决策树多生长一层，对样本量的需求会更增加一倍，以限制树深度能够有效地限制过拟合。在<strong>集成算法</strong>中也非常实用。在实际中，可以先从3开始，根据结果再决定是否增加深度。也就是说最终结果只有max_depth层，超过这个数值的层将会被全部删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>, </span><br><span class="line">                                  random_state=<span class="number">0</span>,</span><br><span class="line">                                  splitter=<span class="string">&quot;random&quot;</span>,</span><br><span class="line">                                  max_depth=<span class="number">3</span>)</span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)</span><br><span class="line">score</span><br></pre></td></tr></table></figure>

<p>这个结果跟原来的一样，说明，原先的决策树3层往后是多余的，更推荐使用这个，计算少，正确率高。</p>
<h4 id="6-1-2-min-samples-leaf"><a href="#6-1-2-min-samples-leaf" class="headerlink" title="6.1.2 min_samples_leaf"></a>6.1.2 min_samples_leaf</h4><p>min_samples_leaf限定后，一个节点在分枝后，每个子节点必须包含至少min_samples_leaf个训练样本，否则该该分枝可能就不会发生，或者，分枝会朝着满足每个节点都包含样本个数达到min_samples_leaf个样本的方向发生。</p>
<p>一般是搭配max_depth一起用，在回归树中，可以让模型变得更加平滑。这个参数的数量设置太小可能会引起过拟合，设置得太大就会阻止模型学习数据。一般建议从5开始使用。如果叶节点含有得样本数量大，建议输入浮点数作为样本量百分比来使用，同时这个参数可以保证每个叶子得最小尺寸。避免低方差，过拟合的叶子节出现。类别不同的问题，1通常是最好的选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>, </span><br><span class="line">                                  random_state=<span class="number">0</span>,</span><br><span class="line">                                  splitter=<span class="string">&quot;random&quot;</span>,</span><br><span class="line">                                  max_depth=<span class="number">3</span>,</span><br><span class="line">                              	  min_samples_leaf=<span class="number">10</span>)</span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)</span><br><span class="line">score</span><br></pre></td></tr></table></figure>

<p>在原来的叶节点中，有的样本个数都是在10以下，但是加了这个参数之后，这些节点的个数都在10以上了，跟其同级叶子节点的个数平均了。然后得分变低了，不采用这个参数。</p>
<h4 id="6-1-3-min-samples-split"><a href="#6-1-3-min-samples-split" class="headerlink" title="6.1.3 min_samples_split"></a>6.1.3 min_samples_split</h4><p>min_samples_split限定，一个节点必要包含至少min_samples_split个训练样本，这个节点才能被允许分枝，否则分枝就不会发生。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>, </span><br><span class="line">                                  random_state=<span class="number">0</span>,</span><br><span class="line">                                  splitter=<span class="string">&quot;random&quot;</span>,</span><br><span class="line">                                  max_depth=<span class="number">3</span>,</span><br><span class="line">                                  max_samples_split=<span class="number">25</span>)</span><br><span class="line">clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">score = clf.score(Xtest, Ytest)</span><br><span class="line">score</span><br></pre></td></tr></table></figure>

<p>在图中我们可以发现，它的节点(样本数小于25的)已经不再分了。得分更低，不采用。</p>
<h4 id="6-1-4-max-features"><a href="#6-1-4-max-features" class="headerlink" title="6.1.4 max_features"></a>6.1.4 max_features</h4><p>max_features限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃。</p>
<p>max_features是用来限制高纬度数据的过拟合的剪枝参数，其方法更加直接。比如900个特征，只选择max_features个。是直接限制可以使用的特征个数，而强制让决策树停下的参数。在不知道决策树各个特征重要程度的前提下，不要使用，避免学习不足。如果希望降维的话，还是建议使用PCA、ICA或者其他降维方法。</p>
<h4 id="6-1-5-min-impurity-decrease"><a href="#6-1-5-min-impurity-decrease" class="headerlink" title="6.1.5 min_impurity_decrease"></a>6.1.5 min_impurity_decrease</h4><p>min_impurity_decrease限制信息增益的大小。信息增益小于设定数值的分枝不会发生。</p>
<h2 id="6-2-确认最优的剪枝参数"><a href="#6-2-确认最优的剪枝参数" class="headerlink" title="6.2 确认最优的剪枝参数"></a>6.2 确认最优的剪枝参数</h2><p>那么我们该如何确定每个参数应该怎么填呢？手段填的话，未免会效率很低。这个时候，我们就要使用超参数的曲线来判断了，继续使用我们已经训练好的决策树模型clf。超参数的学习曲线，是一条以超参数的取值为横坐标，模型的度量指标为纵坐标的曲线，它是用来衡量不通过超参数取值下模型的表现的线。我们这个模型中，模型的度量指标就是score。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何确定最优的参数</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">test = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    clf = tree.DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,</span><br><span class="line">                                      random_state=<span class="number">0</span>,</span><br><span class="line">                                      splitter=<span class="string">&#x27;random&#x27;</span>,</span><br><span class="line">                                      max_depth=i+<span class="number">1</span>  </span><br><span class="line">                                                        )</span><br><span class="line">    clf = clf.fit(Xtrain, Ytrain)</span><br><span class="line">    score = clf.score(Xtest, Ytest)</span><br><span class="line">    test.append(score)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">10</span>), test, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;max_depth&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong></p>
<p>剪枝参数一定能够提升模型在测试上的表现嘛？</p>
<h2 id="7-重要属性和接口"><a href="#7-重要属性和接口" class="headerlink" title="7. 重要属性和接口"></a>7. 重要属性和接口</h2><p>属性是在模型训练之后，能够调用查看的模型的各种性质。对决策树来说，最重要的属性就是feature_importances_ 能够查看各个特征对模型的重要性，</p>
<p>sklearn中许多的算法的接口都是相似的，比如fit、score，几乎对每个算法都可以使用这两个接口，决策树的最常用的接口还有apply和predict。apply中输入测试集并返回每个测试样本所对应的类别的索引，predict输入测试集返回每个测试样本的标签。返回的内容一目了然并且很容易。</p>
<p><strong>所有的接口中要求输入的X_train，X_test的部分，输入的特征的特征矩阵至少是一个二维矩阵，sklearn不接收任何一维矩阵作为特征矩阵被输入。</strong>如果只有一个特征，那必须使用reshape来增加矩阵的维度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apply返回每个测试样本所在叶子节点的索引</span></span><br><span class="line">clf.apply(Xtest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># predict返回每个测试样本的分析/回归结果</span></span><br><span class="line">clf.predict(Xtest)</span><br></pre></td></tr></table></figure>



<h1 id="回归树-DecisonTreeRegressor"><a href="#回归树-DecisonTreeRegressor" class="headerlink" title="回归树(DecisonTreeRegressor)"></a>回归树(DecisonTreeRegressor)</h1><h2 id="1-理论解释"><a href="#1-理论解释" class="headerlink" title="1. 理论解释"></a>1. 理论解释</h2><p>对于分类树来说，它的标签是离散型的，如果标签是连续型的呢？这个时候我们就用到了回归树。</p>
<p>假设X和Y分别作为输入和输出变量，并且Y是连续变量，给定训练数据集$D={(x_{1}, y_{1}), (x_{2}, y_{2}), \cdots , (x_{N}, y_{N}) }$考虑如何生成回归树</p>
<ul>
<li><strong>如何选择划分点？</strong></li>
<li><strong>如何决定树中叶节点的输出值？</strong></li>
</ul>
<p>一个回归树对应着输入空间(特征空间)的一个划分以及在划分单元上的输出值。假设输入空间划分为M个单元$R_{1}, R_{2}, \cdots, R_{M}$，斌且每个单元$R_{m}$上有一个固定的输出值$c_{m}$，所以回归树模型可以表示为：<br>$$<br>f(x)=\sum_{m=1}^Mc_{m}I(x\in R_{m})<br>$$<br>可以用平方误差$\sum_{x_{i}\in R_{m}}(y_{i}-f(x_{i}))^2$来表示回归树对于训练树据的预测误差，用平方误差最小的准则来求解每个单元上的最优输出值。易知，$R_{m}$上的$c_{m}$的最优值$\hat{c}_m$是$R_m$上所有的输入实例$x_i$对应输出$y_i$的均值，即：<br>$$<br>\hat{c}_m = ave(y_i|x_i \in R_m)<br>$$</p>
<ul>
<li><p><strong>问题1：怎样对输入空间进行划分？即如何选择划分点？</strong></p>
<p>CART回归树采用启发式的方法对输入空间进行划分，选择第j个变量$x^{(j)}$和它的取值s，作为切分变量和切分点，斌且定义两个区域：<br>$$<br>R_{1}(j,s)=(x|x^{(j)} \leq s)和R_{2}(j,s)=(x|x^{(j)} &gt; s )<br>$$<br>然后我们就可以寻找到最优切分变量j和最优切分点s。具体求解<br>$$<br>min_{j,s}[min_{c_{1}}\sum_{x_{i}\in R_{1}(j,s)}(y_{i}-c_{1})^2+min_{c_{2}}\sum_{x_{2}\in R_{2}(j,s)}(y_{i}-c_{2})^2]<br>$$<br>对于固定的输入变量j可以找到最优切分点s</p>
</li>
<li><p><strong>问题2：如何决定树中叶节点的输出值？</strong></p>
<p>用选定的最优切分变量j和最优切分点s划分区域并决定相应的输出值：<br>$$<br>\hat{c}_1 =ave(y_i | x_i \in R_1 (j,s) ) 和 \hat{c}_2=ave (y_i |x_i \in R_2 (j,s) )<br>$$<br>遍历所有的输入变量，找到最优的切分变量j，构成一个对（j, s）。依此将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成一颗回归树。这样的回归树通常称为最小二乘回归树（least squares regression tree）。</p>
</li>
</ul>
<h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>输入：训练数据集D</p>
<p>输出：回归树f(x)</p>
<p>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上地输出值，构建二叉决策树：</p>
<ol>
<li>选择最优切分变量j和切分点s，求解</li>
</ol>
<p>$$<br>min_{j,s}[min_{c_{1}}\sum_{x_{i}\in R_{1}(j,s)}(y_{i}-c_{1})^2+min_{c_{2}}\sum_{x_{2}\in R_{2}(j,s)}(y_{i}-c_{2})^2]<br>$$</p>
<p>​        遍历变量j，对固定地切分变量j扫描切分点s，使其结果达到最小值的对(j, s)</p>
<ol start="2">
<li><p>选定的对(j, s)划分区域并决定相应的输出值：<br>$$<br>R_1(j,s)={ x|x_(j) \leq s }, R_2(j, s)=(x| x_j &gt; s )<br>$$</p>
<p>其中对于上式有：<br>$$<br>\hat{c}<em>m= \frac{1}{N_m}\sum</em>{x_i\in R_m(j,s)} y_i, x_i\in R_m, m=1,2<br>$$</p>
</li>
<li><p>继续对两个子区域调用步骤1和步骤2，知道满足停止条件</p>
</li>
<li><p>将输入空间划分为M个区域$R_{1}, R_{2}, \cdots, R_{M}$，生成决策树：<br>$$<br>f(x)=\sum_{m=1}^M\hat{c}_mI(x\in R_m)<br>$$</p>
</li>
</ol>
<h2 id="3-回归树实例"><a href="#3-回归树实例" class="headerlink" title="3. 回归树实例"></a>3. 回归树实例</h2><p>试用平方误差损失准则生成一个二叉回归树</p>
<table>
<thead>
<tr>
<th>$x_{i}$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>$y_{i}$</td>
<td>4.50</td>
<td>4.75</td>
<td>4.91</td>
<td>5.34</td>
<td>5.80</td>
<td>7.05</td>
<td>7.90</td>
<td>8.23</td>
<td>8.70</td>
<td>9.00</td>
</tr>
</tbody></table>
<p>选择最优切分变量j和切分点s：<br>$$<br>min_{j,s}[min_{c_{1}}\sum_{x_{i}\in R_{1}(j,s)}(y_{i}-c_{1})^2+min_{c_{2}}\sum_{x_{2}\in R_{2}(j,s)}(y_{i}-c_{2})^2]<br>$$<br>其中：</p>
<p>$c_{1}=ave(y_{i} | x_{i} \in R_{1}(j,s)) 和c_{2}=ave(y_{i} | x_{i} \in R_{2}(j,s))$</p>
<p>例如，取s=1。此时有$R_{1}={1}, R_{2}={2, 3, 4, 5, 6, 7, 8, 9, 10 }$，这两个区域的输出值分别为：</p>
<p>$c_{1}=4.50$</p>
<p>$c_{2}=\frac{1}{9}(4.75+4.91+5.34+5.80+7.05+7.90+8.23+8.70+9.00)=6.85$</p>
<p>根据上述计算得到下表：</p>
<table>
<thead>
<tr>
<th>s</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>$c_{1}$</td>
<td>4.50</td>
<td>4.63</td>
<td>4.72</td>
<td>4.88</td>
<td>5.06</td>
<td>5.39</td>
<td>5.75</td>
<td>5.18</td>
<td>6.35</td>
<td>6.62</td>
</tr>
<tr>
<td>$c_{2}$</td>
<td>6.85</td>
<td>7.12</td>
<td>7.43</td>
<td>7.78</td>
<td>8.18</td>
<td>8.46</td>
<td>8.64</td>
<td>8.85</td>
<td>9.00</td>
<td>0.00</td>
</tr>
</tbody></table>
<p>把$c_{1}, c_{2}$的值带入到均方差中：</p>
<p>$m(1)=(4.50-4.50)^2+(4.75-6.85)^2+(4.91-6.85)^2+(5.34-6.85)^2+(5.80-6.85)^2+(7.05-6.85)^2+(8.23-6.85)^2+(8.70-6.85)^2+(9.00-6.85)^2$</p>
<p>其中跟$c_{1}$有关的只有第一项，跟$c_{2}$有关的则是有9项。</p>
<p>同理，我们可以得知：</p>
<table>
<thead>
<tr>
<th>s</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>m(s)</td>
<td>22.65</td>
<td>17.70</td>
<td>12.19</td>
<td>7.38</td>
<td>3.36</td>
<td>5.07</td>
<td>10.05</td>
<td>15.18</td>
<td>21.33</td>
<td>27.63</td>
</tr>
</tbody></table>
<p>显然取s=5时，m(s)有最小，所以第一个最优切分变量为：j=x、最优切分点为：s=5。</p>
<p>用选定的(j, s)划分区域，并决定输出值：</p>
<p>两个划分区域分别是：$R_{1}={1,2,3,4,5 }, R_{2}={6,7,8,9,10 }$。输出值用公式：<br>$$<br>\hat{c}<em>{1}=ave(y</em>{i}|x_{i}\in R_{1}(j,s))和\hat{c}<em>{2}=ave(y</em>{i}|x_{i}\in R_{2}(j,s))<br>$$<br>得到$c_{1}=5.06, c_{2}=8.18$</p>
<p>然后对两个子区域继续调用算法流程中的步骤(1)、（2)</p>
<p>对$R_{1}$继续划分：</p>
<table>
<thead>
<tr>
<th>$x_{i}$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>$y_{i}$</td>
<td>4.50</td>
<td>4.75</td>
<td>4.91</td>
<td>5.34</td>
<td>5.80</td>
</tr>
</tbody></table>
<p>取切分点分别为：[1, 2, 3, 4, 5]，则各个区域的输出值c如下：</p>
<table>
<thead>
<tr>
<th>s</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>$c_{1}$</td>
<td>4.50</td>
<td>4.63</td>
<td>4.72</td>
<td>4.88</td>
<td>5.06</td>
</tr>
<tr>
<td>$c_{2}$</td>
<td>5.20</td>
<td>5.35</td>
<td>5.57</td>
<td>5.80</td>
<td>0.00</td>
</tr>
</tbody></table>
<p>计算m(s):</p>
<table>
<thead>
<tr>
<th>s</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>m(s)</td>
<td>0.67</td>
<td>0.43</td>
<td>0.19</td>
<td>0.37</td>
<td>1.06</td>
</tr>
</tbody></table>
<p>s=3时，m(3)最小。</p>
<p>然后进行递归，可以得到完整的二叉回归树。</p>
<h2 id="4-sklearn中的回归树"><a href="#4-sklearn中的回归树" class="headerlink" title="4.sklearn中的回归树"></a>4.sklearn中的回归树</h2><h3 id="4-1-重要参数，属性和接口"><a href="#4-1-重要参数，属性和接口" class="headerlink" title="4.1 重要参数，属性和接口"></a>4.1 重要参数，属性和接口</h3><ul>
<li><strong>criterion</strong></li>
</ul>
<p>回归树衡量分枝质量的指标，支持的标准有三种：</p>
<ol>
<li>输入“mse“使用均方差(MSE)，父节点和叶子节点直接的均方误差的差额将作为特征选择的标准，这种方法通过使用叶子节点的均值来最小化$L_{2}$损失。</li>
<li>输入”friedman_mse“使用费尔德曼均方误差，这样的指标使用针对潜在分枝种的问题改进方法。</li>
<li>输入”mae“使用绝对平均误差MAE，这种指标使用叶节点的中值来最小化$L{1}$损失。</li>
</ol>
<p><strong>在回归树种，MSE不只是我们的分枝质量衡量标准，也是我们常用的衡量回归树回归质量的指标。</strong></p>
<p>当我们在交叉验证的时候，或者其他方式获取回归树的结果时候，我们往往会选择均方误差作为我们的评估(score是准确率)。在回归中，我们追求的是MSE越小越好。然后回归树的接口score返回的是$R^2$而不是<strong>MSE</strong>。<br>$$<br>R^2=1-\frac{u}{v}<br>$$<br>$u=\sum_{i=1}^{N}(f_{i}-y_{i})^2,v=\sum_{i=1}^{N}(y_{i}-\bar{y_{i}})^2$</p>
<p>其中u是残差平方和，v是总平方和。</p>
<h3 id="4-2-交叉验证"><a href="#4-2-交叉验证" class="headerlink" title="4.2 交叉验证"></a>4.2 交叉验证</h3><p>对于模型的训练，我们最简单的想法就行把整个数据集分成两个部分，一部分用于训练，另一部分用于验证，也就是常说的训练集和测试集。</p>
<p>这样会有一个弊端，也就是模型与参数的选取将极大程度依赖于对训练集和测试集的划分。不同划分下，TEST的MSE的变动是很大的，而且对应的最优degree也是不一样的。如果我们对于训练集和测试集的划分方法不够好，很可能不能得到最好的模型和参数。</p>
<h4 id="4-2-1-LOOCV"><a href="#4-2-1-LOOCV" class="headerlink" title="4.2.1 LOOCV"></a>4.2.1 LOOCV</h4><p>LOOCV也包含将数据集分成训练集和测试集这一步骤。但是不同的是，我们只用一个数据作为测试集，其他剩余的数据都作为训练集，并且将此步骤重复N次。(N是数据集的数据量)</p>
<p>就比如于n个数据{1, 2, 3, …, n}，LOOCV的方法就是每次取一个数据作为测试集的唯一元素，而其他的n-1个数据作为训练集用于训练模型和调参。比如第一次用1来作为测试集，则剩下的数据{2, 3, 4, …, n}就可以作为它的训练集，依次类推，直到用n来作为测试集，剩下的数据作为训练集为止。结果就是我们最终训练了n个模型，每次都能得到一个MSE。最终test MSE则就是将这n个MSE取平均。<br>$$<br>CV_{n} = \frac{1}{n}\sum_{i=1}^{n}MSE_{i}<br>$$</p>
<ul>
<li>优点：首先它不受测试集合训练集划分方法的影响，因为每一个数据都单独的做过测试集。同时，其用了n-1个数据训练模型，也几乎用到了所有的数据，保证了模型的bias更小。</li>
<li>缺点：那就是计算量过于大，是test set approach耗时的n-1倍。</li>
</ul>
<p>为了解决计算成本太大的弊端，对算法进行更进，使得LOOCV计算成本和只训练一个模型一样快。<br>$$<br>CV_{n}=\frac{1}{n}\sum_{i=1}^{n}(\frac{y_{i}-\hat{y_{i}}}{1-h_{i}})^{2}<br>$$</p>
<h4 id="4-2-2-k-fold-Cross-Validation"><a href="#4-2-2-k-fold-Cross-Validation" class="headerlink" title="4.2.2 k-fold Cross Validation"></a>4.2.2 k-fold Cross Validation</h4><p>k折交叉验证和LOOCV的不同在于，我们每次的测试集不再只包含一个数据，而是多个，具体数目将根据K的选取来决定。比如，k=5，那么我们利用五折交叉验证的步骤就是：</p>
<ol>
<li><p>将所有数据集分成5份</p>
</li>
<li><p>不重复地每次取其中一份作为测试集，用其他四份作训练集训练模型，之后计算该模型在测试集上的$MSE_{i}$</p>
</li>
<li><p>将5次的$MSE_{i}$取平均得到最后的MSE<br>$$<br>CV_{k} = \frac{1}{k}\sum_{i=1}^{k}MSE_{i}<br>$$</p>
</li>
</ol>
<p>不难理解，其实LOOCV是一种特殊的k-fold Cross Validation (K=N)。</p>
<h4 id="4-2-3-Bias-Variance-Trade-Off-for-k-Fold-Cross-Validation"><a href="#4-2-3-Bias-Variance-Trade-Off-for-k-Fold-Cross-Validation" class="headerlink" title="4.2.3 Bias-Variance Trade-Off for k-Fold Cross-Validation"></a>4.2.3 Bias-Variance Trade-Off for k-Fold Cross-Validation</h4><p>最后，我们要说说K的选取。事实上，和开头给出的文章里的部分内容一样，K的选取是一个Bias和Variance的trade-off。</p>
<p>K越大，每次投入的训练集的数据越多，模型的Bias越小。<strong>但是K越大，又意味着每一次选取的训练集之前的相关性越大</strong>（考虑最极端的例子，当k=N，也就是在LOOCV里，每次都训练数据几乎是一样的）。而这种大相关性会导致最终的test error具有更大的Variance。</p>
<p>一般来说，根据经验我们一般选择k=5或10。</p>
<h4 id="4-2-4-sklearn种交叉验证的实现"><a href="#4-2-4-sklearn种交叉验证的实现" class="headerlink" title="4.2.4 sklearn种交叉验证的实现"></a>4.2.4 sklearn种交叉验证的实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line">boston = load_boston()</span><br><span class="line">regressor = DecisionTreeRegressor(random_state=<span class="number">0</span>)</span><br><span class="line">cross_val_score(regressor, boston.data, boston.target, cv=<span class="number">5</span>,</span><br><span class="line">                scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在cross_val_score这个函数中，regressor是任一构建好的模型实例，可是是SVM等等，后两个参数直接输人原始数据，不需要有任何改动或者划分。cv参数就是将数据集划分的个数。因为在回归树中，我们一般是看其MSE，所以加上scoring参数，要不然返回的就是得分。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：线性表</title>
    <url>/2021/12/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="1-线性表的定义和特点"><a href="#1-线性表的定义和特点" class="headerlink" title="1. 线性表的定义和特点"></a>1. 线性表的定义和特点</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>就是很简单由n个数据特性相同的元素构成的有限序列称为线性表。</p>
<h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ol>
<li>存在<strong>唯一</strong>一个被称作“第一个”的数据元素。</li>
<li>存在<strong>唯一</strong>的一个被称作“最后一个”的数据元素。</li>
<li>除了第一个之外，结构中的每个数据元素均只有<strong>一个前驱。</strong></li>
<li>除了最后一个之外，结构中的每个数据元素只有<strong>一个后继。</strong></li>
</ol>
<span id="more"></span>

<h2 id="2-顺序表"><a href="#2-顺序表" class="headerlink" title="2. 顺序表"></a>2. 顺序表</h2><h3 id="2-1-顺序存储表示基本定义"><a href="#2-1-顺序存储表示基本定义" class="headerlink" title="2.1 顺序存储表示基本定义"></a>2.1 顺序存储表示基本定义</h3><p>指得是用一组<strong>地址连续</strong>的存储单元结构依次存储线性表的数据元素。<strong>他们的逻辑上是相邻的，其物理次序也是相邻的。</strong></p>
<h3 id="2-2-顺序表的代码实现"><a href="#2-2-顺序表的代码实现" class="headerlink" title="2.2 顺序表的代码实现"></a>2.2 顺序表的代码实现</h3><h4 id="2-2-1-线性表的简单操作"><a href="#2-2-1-线性表的简单操作" class="headerlink" title="2.2.1 线性表的简单操作"></a>2.2.1 线性表的简单操作</h4><ol>
<li><p>线性表的销毁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(Sqlist &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem) &#123;</span><br><span class="line">        <span class="keyword">delete</span> L.elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>清空线性表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(Sqlist &amp;L)</span> </span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求线性表的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(Sqlist L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>判断线性表L是否为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Sqlist L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.Length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-2-算法中预定的常量"><a href="#2-2-2-算法中预定的常量" class="headerlink" title="2.2.2 算法中预定的常量"></a>2.2.2 算法中预定的常量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFFASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="comment">//Status是函数类型，其值是函数结果状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType; <span class="comment">//char是可以自己更换的</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-顺序表L的初始化"><a href="#2-2-3-顺序表L的初始化" class="headerlink" title="2.2.3 顺序表L的初始化"></a>2.2.3 顺序表L的初始化</h4><p>在如下的代码中，if语句是用来判断的，异常值处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(Sqlist &amp;L)</span> </span>&#123;</span><br><span class="line">    L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    L.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-顺序表的取值"><a href="#2-2-4-顺序表的取值" class="headerlink" title="2.2.4 顺序表的取值"></a>2.2.4 顺序表的取值</h4><p><strong>随机存取</strong>，并且时间复杂程度是O(1)，其具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(Sqlist L, <span class="keyword">int</span> L, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.Length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-顺序表的查找-按值查找"><a href="#2-2-5-顺序表的查找-按值查找" class="headerlink" title="2.2.5 顺序表的查找(按值查找)"></a>2.2.5 顺序表的查找(按值查找)</h4><ul>
<li><p>查找算法的实现步骤</p>
<ol>
<li>从第一个元素起，依次和e相比较，若找到与e相等的元素，查找成功，返回该元素的序号。</li>
<li>若查遍整个顺序表都没有找到，则查找失败，返回0。</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, Elemtype e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;L.Length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.elemp[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>算法分析</p>
<p>假如$p_{i}$是查找第$i$个元素的概率，$c_{i}$是找到第$i$个记录需要比较的次数，则在长度为$n$的线性表中，查找成功时的平均查找长度为：  </p>
<p>​                                                                            $$ ASL=\sum_{i=1}^{n}p_{i}C_{i}$$</p>
<p>其中如果需要查找的时第一个元素的时候，则只需要比较一次，而查找表中最后一个记录时，则需要比较$n$次，一般情况下$c_{i}=i$。假设每个元素的查找概率相等，即：</p>
<p>​                                                                            $$p_{i} = \frac{1}{n}$$</p>
<p>则表达式可以化简为：</p>
<p>​                                                                            $$ASL=\frac{1}{n}\sum_{i=1}^{n}i=\frac{n+1}{2}$$</p>
<p>由此可见，顺序表按值查找算法的平均时间复杂程度为O(n)。</p>
</li>
</ul>
<h4 id="2-2-6顺序表的插入"><a href="#2-2-6顺序表的插入" class="headerlink" title="2.2.6顺序表的插入"></a>2.2.6顺序表的插入</h4><ul>
<li><p>插入的算法步骤</p>
<ol>
<li>判断插入位置$i$是否合法($i$值的合法范围是($1\leq i \leq n+1$))，若不合法，则返回ERROR。</li>
<li>判断顺序表的存储空间是否已满，若满则返回ERROR。</li>
<li>将第$n$个至第$i$个位置的元素，依次向后移动一个位置，空出第$i$个位置($i=n+1$时，无需移动)。</li>
<li>将要插入的新元素$e$放入第$i$个位置。</li>
<li>表长加1。</li>
</ol>
</li>
<li><p>插入代码的具体实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, Elemtype e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i值的合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.Length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 当前存储空间已满</span></span><br><span class="line">    <span class="keyword">if</span>(L.Length == MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 插入位置及之后的元素后移(从n开始)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = L.Length; j&gt;=i<span class="number">-1</span>; j--) &#123;</span><br><span class="line">        L.elem[j+<span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新元素放入第i个位置</span></span><br><span class="line">    L.elem[i<span class="number">-1</span>] = e;</span><br><span class="line">    <span class="comment">// 表长加一</span></span><br><span class="line">    L.Length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>算法分析</p>
<p>假设$p_{i}$是第$i$个元素之前插入一个元素的概率，$E_{ins}$为在长度为$n$的线性表中插入一个元素时，所需要移动元素的次数的期望值(平均次数)，则有：</p>
<p>​                                                                    $$E_{ins} = \sum_{i=1}^{n+1}p_{i}(n-i+1)$$</p>
<p>为了一般性，可以设置在线性表的任何位置上插入元素都是等概率的，即：</p>
<p>​                                                                    $$p_{i} = \frac{i}{n+1}$$</p>
<p>则原式可以简化为：</p>
<p>​                                                                    $$E_{ins}=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}$$</p>
<p>综上，顺序表的插入算法的时间平均复杂度为O(n)。</p>
</li>
</ul>
<h4 id="2-2-7-顺序表的删除"><a href="#2-2-7-顺序表的删除" class="headerlink" title="2.2.7 顺序表的删除"></a>2.2.7 顺序表的删除</h4><ul>
<li><p>删除算法的步骤</p>
<ol>
<li>判断要删除的位置是否合法($1\leq i \leq n$)。</li>
<li>将第i+1个至第n个的元素依次向前移动一个位置(i=n时，无需移动)。</li>
<li>表长减1</li>
</ol>
</li>
<li><p>删除算法的具体实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断i值合法程度</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.Length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;L.Length<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        L.elem[j<span class="number">-1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.Length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>算法分析</p>
<p>假设$p_i$是删除第$i$个元素的概率，则$E_{del}$为长度为$n$的线性表中删除一个元素时所需要移动元素次数的期望值(平均次数)，则有</p>
<p>​                                                                        $$E_{del} = \sum_{i=1}^{n}p_{i}(n-i)$$</p>
<p>为了保证一般性，假设任何位置被删除的概率都是相等的，即：</p>
<p>​                                                                        $$p_{j}=\frac{1}{n}$$</p>
<p>所以原式可以化简为：</p>
<p>​                                                                        $$E_{del} = \frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$$</p>
<p>综上所述：顺序表删除的平均算法时间复杂程度为O(n)。</p>
</li>
</ul>
<h3 id="2-3-顺序表的优缺点"><a href="#2-3-顺序表的优缺点" class="headerlink" title="2.3 顺序表的优缺点"></a>2.3 顺序表的优缺点</h3><ol>
<li><p>优点</p>
<ul>
<li><p>存储密度大</p>
</li>
<li><p>可以随机存取表中任意元素(知道地址和索引后，直接访问)</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>在插入、删除某一元素时，需要大量移动元素</li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充</li>
</ul>
</li>
</ol>
<h3 id="2-4-顺序表的特点"><a href="#2-4-顺序表的特点" class="headerlink" title="2.4 顺序表的特点"></a>2.4 顺序表的特点</h3><p>简单来说就是逻辑关系相邻的数据，他们的存储也是相邻的。</p>
<ul>
<li>特点<ol>
<li>地址连续</li>
<li>依次存放</li>
<li>随机存取</li>
<li>类型相同</li>
</ol>
</li>
</ul>
<p>我们可以发现，其特点和数据很像，但是表长可变，数组长度不可动态定义。</p>
<h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><h3 id="3-1-单链表中的相关定义"><a href="#3-1-单链表中的相关定义" class="headerlink" title="3.1 单链表中的相关定义"></a>3.1 单链表中的相关定义</h3><ol>
<li>结点：存储直接后继位置的域成为<strong>指针域</strong>。指针域中存储的信息成为<strong>指针</strong>或<strong>链。</strong>其中存储数据元素信息的域称为<strong>数据域</strong>。</li>
<li>首元结点：是指链表中存储第一个数据元素$a_{1}$的结点。</li>
<li>头指针：是指向链表中<strong>第一个结点</strong>的指针。若链表设有头结点，则头指针所指向结点为线性表的<strong>头结点</strong>；若不设头结点，则头指针所指向结点为该线性表的<strong>首元结点</strong>。它存储的是头结点的地址或者首元结点的地址。</li>
<li>头结点：是指在首元结点之前附设一个结点，其指针域指向<strong>首元结点</strong>，头结点的数据域可以不存储任何信息，也可以存储对链表的其他的附加信息。</li>
<li>其他链表：<ul>
<li>单链表：结点只有一个指针域的链表</li>
<li>双链表：结点有两个指针域的链表</li>
<li>循环链表：首尾相接的链表</li>
</ul>
</li>
</ol>
<h3 id="3-2-单链表的代码实现"><a href="#3-2-单链表的代码实现" class="headerlink" title="3.2 单链表的代码实现"></a>3.2 单链表的代码实现</h3>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：基础导论</title>
    <url>/2021/12/24/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-数据"><a href="#1-1-数据" class="headerlink" title="1.1 数据"></a>1.1 数据</h3><p><strong>数据</strong>是客观事物的符号表示，是所有能输入到计算机并且被计算机程序所处理的符号的总称。</p>
<h3 id="1-2-数据项"><a href="#1-2-数据项" class="headerlink" title="1.2 数据项"></a>1.2 数据项</h3><p>数据项是组成数据元素有<strong>独立含义的、不可分割的最小单位。</strong></p>
<h3 id="1-3-数据元素"><a href="#1-3-数据元素" class="headerlink" title="1.3 数据元素"></a>1.3 数据元素</h3><p>数据元素是数据的<strong>基本单位</strong>，在计算机中通常作为一个整体考虑。</p>
<h3 id="1-4-数据对象"><a href="#1-4-数据对象" class="headerlink" title="1.4 数据对象"></a>1.4 数据对象</h3><p>数据对象是<strong>性质相同的数据元素的集合</strong>，是数据的一个子集。</p>
<span id="more"></span>



<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合，也就是说数据是带“结构”的数据元素的集合，“结构”则指数据元素之间的关系。</p>
<h3 id="2-1-逻辑结构"><a href="#2-1-逻辑结构" class="headerlink" title="2.1 逻辑结构"></a>2.1 逻辑结构</h3><ul>
<li>基本概念：数据的逻辑结构是从逻辑关系上描述数据的，它与数据的存储位置无关，是独立于计算机的。</li>
<li>两个元素：一个是<strong>数据元素</strong>和<strong>关系。</strong></li>
</ul>
<h4 id="2-1-1-线性结构"><a href="#2-1-1-线性结构" class="headerlink" title="2.1.1 线性结构"></a>2.1.1 线性结构</h4><p>也就是数据元素之前存在<strong>一对一</strong>的关系。</p>
<h4 id="2-1-2-非线性结构"><a href="#2-1-2-非线性结构" class="headerlink" title="2.1.2 非线性结构"></a>2.1.2 非线性结构</h4><ol>
<li>集合结构：数据元素之间除了<strong>属于同一集合</strong>的关系外，没有其他关系了。</li>
<li>树结构：数据元素之间存在<strong>一对多</strong>的关系。</li>
<li>图结构：数据元素之间存在<strong>多对多</strong>的关系。</li>
</ol>
<h3 id="2-2-存储结构"><a href="#2-2-存储结构" class="headerlink" title="2.2 存储结构"></a>2.2 存储结构</h3><h4 id="2-2-1-顺序存储结构"><a href="#2-2-1-顺序存储结构" class="headerlink" title="2.2.1 顺序存储结构"></a>2.2.1 顺序存储结构</h4><p>顺序存储结构是借助元素在存储器中的<strong>相对位置</strong>来表示数据元素之间的逻辑关系，通常借助数据语言中的<strong>数组</strong>类型来描述。</p>
<h4 id="2-2-2-链式存储结构"><a href="#2-2-2-链式存储结构" class="headerlink" title="2.2.2 链式存储结构"></a>2.2.2 链式存储结构</h4><p>跟顺序存储结构相比，它在存储器中的存储发生了改变，不再连续了。为了表示结点之间的关系，还要给每个节点附加指针字段，用于存放后继元素的地址。</p>
<h2 id="3-算法与算法分析"><a href="#3-算法与算法分析" class="headerlink" title="3. 算法与算法分析"></a>3. 算法与算法分析</h2>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章：数据库设计</title>
    <url>/2021/12/07/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h1><ol>
<li>需求分析</li>
<li>概念结构设计    ER图或者是设计数据字典</li>
<li>逻辑结构设计    把ER图转为逻辑模型</li>
<li>物理结构设计    把逻辑模型转为物理模型</li>
<li>数据库实验      写SQL代码</li>
<li>数据库运行维护   性能检测<span id="more"></span>
<h1 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h1></li>
<li>实体是长方形</li>
<li>而属性是椭圆形</li>
<li>关系为菱形</li>
<li>1对1(1:1)：1对1关系是指对于实体集与实体集B，A中的每一个实体至多与B中一个实体有关系。</li>
<li>1对多(1:N)：1对多关系是指实体集A与实体集B中至少有N个实体有关系，并且实体集B中每一个实体至多与实体集A中一个实体有关系。</li>
<li>多对多(N:M)：多对多关系是指实体集A中的每一个实体与实体集B中至少M个实体有关系，并且实体集B中每一个实体与实体集A中至少N个实体有关系。</li>
</ol>
<h1 id="ER图转为关系模式"><a href="#ER图转为关系模式" class="headerlink" title="ER图转为关系模式"></a>ER图转为关系模式</h1><ol>
<li>1:1要把关系合并到任意一个表中，并且把另外的表里面的主键放到另一个表中。</li>
<li>1:n要把A(1)的主码放到B(n)里面，然后把关系的属性放到B(n)里面。</li>
<li>m:n要把两边实体的主键和自身的属性，单独作为一个关系模式。</li>
</ol>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章：关系数据库理论</title>
    <url>/2021/12/07/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p><strong>为什么要引入范式？</strong></p>
<ol>
<li>数据冗余</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常<span id="more"></span></li>
</ol>
<p><strong>范式分类</strong></p>
<blockquote>
<p>设计关系数据库的时候，遵从不同的规范要求，这些不同的规范要求被称为不同的范式，各种范式呈递次范式，越高的范式，数据库冗余越小。<br>目关系数据库有六种范式：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF，也称为完美范式)。</p>
</blockquote>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><ol>
<li><p><strong>非平凡函数依赖</strong></p>
<blockquote>
<p>x-&gt;y，但y不属于x，则称x-&gt;y是非平凡的函数依赖。<br> 也就是说，你是来蹭课的，上课的时候能看见你，但是其实你不属于上这个课的人。</p>
</blockquote>
</li>
<li><p><strong>平凡函数依赖</strong></p>
<blockquote>
<p>x-&gt;y，y属于x，则称x-&gt;y是平凡的函数依赖。<br> 你的班级能够找到你，而且你也是这个班级的。</p>
</blockquote>
</li>
<li><p><strong>完全函数依赖</strong></p>
<blockquote>
<p>定义略。如果X集合能够刚好推出Y来，但是X的真子集就不行。也就是说，如果X集合中少任何一个元素的话，都不能推出Y来。</p>
</blockquote>
</li>
<li><p><strong>部分函数依赖</strong></p>
<blockquote>
<p>定义略。就像学号能推出姓名，学号和身份证号一起也能推出姓名，如果去掉身份证号也没有影响。</p>
</blockquote>
</li>
</ol>
<h1 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h1><blockquote>
<p>概念：能够推出所有的属性</p>
</blockquote>
<h2 id="如何选出候选码？"><a href="#如何选出候选码？" class="headerlink" title="如何选出候选码？"></a>如何选出候选码？</h2><ol>
<li>只出现在左边的一定是候选码</li>
<li>只出现在右边的一定不是候选码</li>
<li>左右都出现的不一定是候选码</li>
<li>左右都不出现的一定是候选码</li>
<li>再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则你要把每一个可能的值放进当前确定的候选码里面求闭包</li>
</ol>
<p>例如：R&lt;U, F&gt;, U&lt;A, B, C, D, E, G&gt;是属性集合, F=(AB-&gt;C, CD-&gt;E, E-&gt;A, A-&gt;G)是映射，求候选码：</p>
<blockquote>
<p>解：我们可以的知：<br>一定是候选码：B、D<br>一定不是候选码：G<br>不一定是候选码：A、C、E<br>BD啥也推不出来，所以要把每一个不一定都放进去测试<br>(BDA)+ = 可推出：C、E、G   所以可以推出ABCDEG<br>(BDC)+ = 可推出：E、A、G   所以可以推出ABCDEG<br>(BDE)+ = 可推出：A、G、C   所以可以推出ABCDEG<br>综上所述，候选码是{(BDA),(BDC),(BDE)};</p>
</blockquote>
<h2 id="一些其他的概念"><a href="#一些其他的概念" class="headerlink" title="一些其他的概念"></a>一些其他的概念</h2><ol>
<li>超码：能表示出所有属性的集合，比如(BDA), (BDC), (BDE), BDCA, BDEA, ABCDE。候选码是最小的超码。</li>
<li>主码：从候选码里面任意选出一个作为主码。</li>
<li>主属性：包含在所有候选码的属性，比如ABCDE</li>
<li>非主属性：不包含在候选码中的属性，比如G</li>
<li>全码：所有的属性都是主码</li>
</ol>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><ol>
<li>1NF<blockquote>
<p>所有字段值都是不可以分解的原子值<br>比如某些系统需要”地址”这个属性，本来讲地址设置为一个数据表的字段就行，但是如果系统经常会访问”地址”属性中”城市”的部分，那么就非要讲”地址”这个属性值重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候会很方便。</p>
</blockquote>
</li>
<li>2NF<blockquote>
<p>不包含非主属性对码的部分函数依赖，一个表只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
</blockquote>
</li>
<li>3NF<blockquote>
<p>不包含非主属性对码的传递函数依赖，确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
</blockquote>
</li>
<li>BCNF<blockquote>
<p>消除每一属性对候选键的传递依赖，BCNF是修正的第三范式。</p>
</blockquote>
</li>
</ol>
<h1 id="求最小的函数依赖集"><a href="#求最小的函数依赖集" class="headerlink" title="求最小的函数依赖集"></a>求最小的函数依赖集</h1><p> <strong>什么是依赖？</strong></p>
<blockquote>
<p>依赖是指关系中一个或一组属性的值可以决定其他属性的值，比如A-&gt;B就是一个依赖。</p>
</blockquote>
<p> <strong>如何求最小依赖？</strong></p>
<ol>
<li>拆右边为多个元素，比如A-&gt;BC拆为A-&gt;B和A-&gt;C</li>
<li>除去当前元素，求它的闭包，把集合里面的元素全部都用完。看看能不能推出当前元素的右端值，可以就不要，不可以就保留。</li>
<li>左边最小化(通过遮住元素看看能不能推出其他的元素)，比如BCD，遮住B，看CD能不能推出B来，如果不能则B就保留，否则就去掉。C和D同理。</li>
</ol>
<p><strong>例题</strong>：已知关系R&lt;U, F&gt;, U{A,B,C,D,E,F,G}, F={BCD-&gt;A, BC-&gt;E, A-&gt;F, F-&gt;G, C-&gt;D, A-&gt;G}求F的最小依赖                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p>
<blockquote>
<p><strong>解</strong>：右边没有可以拆分的。<br>    除去BCD这个元素，(BCD)+ =BCDE，发现没有其他元素可以推出A来，保留。<br>    除去BC这个元素，(BC)+ = BCD，其他元素推不出E，保留。<br>    除去A这个元素，(A)+ = AG，其他元素推不出F，保留。<br>    除去F这个元素，(F)+ = F，其他元素推不出G，保留。<br>    除去C这个元素，(C)+ = D，其他元素推不出D来，保留。<br>    除去A这个元素，(A)+ = FG，可以推出G来，去掉。<br>    然后再把左边多的元素看看能不能拆开，BCD，遮住B，CD并不能推出B，同理，不能推出C，但是D可以被推出，所以BCD变成BD。<br>    综上所述：最小依赖为{BC-&gt;A, BC-&gt;E, A-&gt;F, F-&gt;G, C-&gt;D}</p>
</blockquote>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><ol>
<li>准则：无损连接和保持函数依赖。</li>
<li>无损：就是分解后再次连接，和分解之前一样。</li>
<li>依赖：依赖不变。</li>
</ol>
<p><strong>例题</strong>：一直R{ABCDEGH}, F={A-&gt;D,E-&gt;D,D-&gt;B,BC-&gt;D,DC-&gt;A}，求保持函数依赖的3NF的分解。</p>
<ol>
<li>求出最小函数依赖集</li>
<li>把不在F里面的属性都找出来，单独分成一类</li>
<li>把每一个依赖左边相同的分为一类，没有一样的，那就把A-&gt;D改成{AD}，如果一样{A-&gt;B, A-&gt;C} 那么就改为{ABC}</li>
<li>如果候选码没出现在分离(最小依赖集)里面，把任意一个候选码作为一类。<blockquote>
<p><strong>解</strong>：最小函数依赖集为：Fmin={A-&gt;D,E-&gt;D,D-&gt;B,BC-&gt;D,DC-&gt;A}。<br>GH不在里面，所以单独分为一类{GH}<br>候选码：CE<br>{AD}{ED}{DB}{BCD}{DCA}{CE}{GH}</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章：数据库完整性</title>
    <url>/2021/12/07/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="数据完整性概述"><a href="#数据完整性概述" class="headerlink" title="数据完整性概述"></a>数据完整性概述</h1><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><blockquote>
<p>符合现实世界的描述</p>
</blockquote>
<h2 id="相容性"><a href="#相容性" class="headerlink" title="相容性"></a>相容性</h2><blockquote>
<p>同一对象在不同表里面是符合逻辑的。比如我的地址、年龄，在两个表里面应该是一样的</p>
</blockquote>
<span id="more"></span>
<h2 id="维护完整性"><a href="#维护完整性" class="headerlink" title="维护完整性"></a>维护完整性</h2><ol>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>进行违约处理</li>
</ol>
<h1 id="三大完整性"><a href="#三大完整性" class="headerlink" title="三大完整性"></a>三大完整性</h1><h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><blockquote>
<p>主码唯一，且非空</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">    <span class="type">time</span> <span class="type">varchar</span>(<span class="number">255</span>), </span><br><span class="line">    <span class="keyword">primary</span> key(id));</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key, </span><br><span class="line">    <span class="type">time</span> <span class="type">varchar</span>(<span class="number">255</span>));</span><br></pre></td></tr></table></figure>

<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><blockquote>
<p>外码要么有，要么只有一个</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">    id <span class="type">int</span>, </span><br><span class="line">    <span class="type">time</span> <span class="type">varchar</span>(<span class="number">255</span>), </span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">255</span>), </span><br><span class="line">    teacher_id <span class="type">int</span>, </span><br><span class="line">    <span class="keyword">primary</span> key(id), </span><br><span class="line">    <span class="keyword">foreign</span> key(id) <span class="keyword">references</span> course_description(course_id));</span><br></pre></td></tr></table></figure>

<h2 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h2><ol>
<li>非空<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">     <span class="keyword">no</span> <span class="type">char</span>(<span class="number">9</span>) <span class="keyword">primary</span> key,</span><br><span class="line">     age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
<li>列值唯一<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">     <span class="keyword">no</span> <span class="type">char</span>(<span class="number">9</span>) <span class="keyword">primary</span> key,</span><br><span class="line">     age <span class="type">int</span> <span class="keyword">unique</span>);</span><br></pre></td></tr></table></figure></li>
<li>满足某个条件表达式 check来写<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">     <span class="keyword">no</span> <span class="type">char</span>(<span class="number">9</span>) <span class="keyword">primary</span> key,</span><br><span class="line">     sex <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">check</span>(sex <span class="keyword">in</span> (<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">     age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><blockquote>
<p>断言创建以后，任何对断言中涉及关系的操作都会触发关系数据库系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。</p>
</blockquote>
<p>其sql语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">check</span> 子句<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<p>例如：限制每一门课程最多有60名学生选修</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion asse_sc_cnum1</span><br><span class="line"><span class="keyword">check</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">                <span class="keyword">from</span> sc</span><br><span class="line">                <span class="keyword">group</span> <span class="keyword">by</span> cno)</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>
<p>删除断言名称：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> assertion <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><blockquote>
<p>触发器也叫做：事件-&gt;条件-&gt;动作 规则。也就是说事件在某个条件满足的时，会触发某个规则。是一段程序，可以在特定的时刻被自动触发执行。</p>
</blockquote>
<p>其sql语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span>   <span class="comment">/*每当触发事件发生时，该触发器被激活*/</span></span><br><span class="line">&#123;before<span class="operator">|</span>after&#125; <span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>表面<span class="operator">&gt;</span>   <span class="comment">/*指明触发器激活的时间是在执行触发事件前或后*/</span></span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span><span class="operator">|</span><span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>   <span class="comment">/*referencing指出引用的变量*/</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span>&#123;<span class="type">row</span><span class="operator">|</span>statement&#125;     <span class="comment">/*定义触发器的类型，指明动作体执行的频率*/</span></span><br><span class="line">[<span class="keyword">when</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>] <span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span>   <span class="comment">/*仅当触发条件为真时才执行触发动作体*/</span> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章：数据库安全性概述</title>
    <url>/2021/12/07/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h1><blockquote>
<p>是指保护数据库以防止不合法使用所造成的数据泄露、更改或者破坏。</p>
</blockquote>
<h2 id="不安全因素"><a href="#不安全因素" class="headerlink" title="不安全因素"></a>不安全因素</h2><ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄露</li>
<li>安全环境的脆弱性<span id="more"></span>
<h2 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h2><blockquote>
<p>主要是通过对用户进行授予或收回对数据的操作权限。</p>
</blockquote>
</li>
<li>grant、revoke<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">to</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>；</span><br><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>；</span><br></pre></td></tr></table></figure></li>
<li>创建用户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span><span class="operator">&lt;</span>username<span class="operator">&gt;</span> <span class="keyword">with</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h1><ol>
<li>用户身份识别：<ol>
<li>静态口令识别</li>
<li>动态口令识别</li>
<li>生物特征识别</li>
<li>智能卡识别</li>
</ol>
</li>
<li>存储控制</li>
<li><strong>自主存取控制方法</strong>：<blockquote>
<p>字面意思就是我们用户可以定义和分配其他用户的操作权限。主要通过grant、revoke来惊喜控制。由两个元素构成：数据对象和操作权限。我们定义用户的存取权限称为授权。</p>
</blockquote>
 主要存取方式<table>
<thead>
<tr>
<th>对象类型</th>
<th>对象</th>
<th>操作类型</th>
</tr>
</thead>
<tbody><tr>
<td>数据库模式</td>
<td>模式</td>
<td>create schema</td>
</tr>
<tr>
<td>数据库模式</td>
<td>基本表</td>
<td>create table、alter table</td>
</tr>
<tr>
<td>数据库模式</td>
<td>视图</td>
<td>create view</td>
</tr>
<tr>
<td>数据库模式</td>
<td>索引</td>
<td>create index</td>
</tr>
<tr>
<td>数据</td>
<td>基本表和视图</td>
<td>select、insert、update、delete、references、all privileges</td>
</tr>
<tr>
<td>数据</td>
<td>属性列</td>
<td>select、insert、update、references、all privileges</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><strong>references权限代表是否允许创建外键、all privileges代表所有权限。</strong></em></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>授权 grant<blockquote>
<p>授权命令是由数据库管理员使用的，若给用户分配权限时使用with grant option语句，则普通用户获权后，可以把自己的权限授予其他人。</p>
</blockquote>
其基本语法如下：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[(属性名)] [,<span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">to</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">grant</span> option];</span><br></pre></td></tr></table></figure></li>
<li>回收权利<br>其基本语法如下：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[(属性名)] [,<span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...[cascade<span class="operator">|</span>restrict];</span><br></pre></td></tr></table></figure></li>
<li>数据库角色<blockquote>
<p>角色就是一类人，比如CEO、总监、普通员工等等，可以给这一类人授权。</p>
</blockquote>
<ol>
<li>角色的创建<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>给角色授权<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">to</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]...</span><br></pre></td></tr></table></figure></li>
<li>将一个角色授予其他的角色或用户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>角色<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>角色<span class="number">2</span><span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">to</span> <span class="operator">&lt;</span>角色<span class="number">3</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span>]...</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<em><strong>角色3获得的是角色1与角色2权限的总和。</strong></em></li>
<li>角色权限的回收<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]...</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h1><blockquote>
<p>就是为不同用户定义不同的视图，把不需要的数据隐藏起来，这样的话用户就不会瞎操作了。</p>
</blockquote>
<h1 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h1><blockquote>
<p>把对数据库的所有操作都记录到审计日志中，然后可以通过日志审查这个里面是否有一些违法的行为</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对修改sc表结构或修改sc表数据的操作进行审计</span></span><br><span class="line"><span class="comment">audit alter, update on sc;</span></span><br><span class="line"><span class="comment">/* 取消对sc表的审计</span></span><br><span class="line"><span class="comment">noaudit alter, update on sc;</span></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：关系数据库标准sql语句</title>
    <url>/2021/12/06/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86sql%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="SQL语言的功能概述"><a href="#SQL语言的功能概述" class="headerlink" title="SQL语言的功能概述"></a>SQL语言的功能概述</h1><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><ol>
<li><strong>模式定义</strong>：在sql中，模式定义语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">authorization</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
 实际上就相当于定义了一个框架，然后再去这个框架里面进一步创建基本表、视图、定义授权等等。  </li>
</ol>
 <span id="more"></span>
<ol start="2">
<li><strong>模式删除</strong>：在sql中，模式删除语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="operator">&lt;</span>cascade<span class="operator">|</span>restrict<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
 <em><strong>注意：选择前者的话，就是说删除模式的同时，也把该模式中所有数据库对象全部删除。选择后者的话，如果该模式中已经定义了下属的数据对象，则就拒绝该操作，该模式没有任何下属的对象才可以删除。</strong></em></li>
</ol>
<h3 id="基本表的定义、删除、与修改"><a href="#基本表的定义、删除、与修改" class="headerlink" title="基本表的定义、删除、与修改"></a>基本表的定义、删除、与修改</h3><ol>
<li><strong>表的定义</strong>：在sql中，表的定义语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[具体要求]</span><br></pre></td></tr></table></figure></li>
<li><strong>表的删除</strong>：在sql中，表的删除语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [cascade<span class="operator">|</span>restrict]</span><br></pre></td></tr></table></figure></li>
<li><strong>表的修改</strong>：在sql中，表中的修改语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[具体要求]</span><br></pre></td></tr></table></figure>
 <em><strong>注意：这些操作都是对表的属性什么的来操作，比如增加属性呀什么的，跟update处理数据要区分开。</strong></em></li>
</ol>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><blockquote>
<p>当表的数据量比较大的时候，查询会比较耗时，索引建立索引来帮助快速查询数据。</p>
</blockquote>
<hr>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>在sql中，数据查询的语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>目标或者表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名或者视图名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>条件表达式或者子查询<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">having</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：having与where作用的对象不同，having操作的对象是组，而where操作的对象是每一个元组。order by只能对最终结果排序。</strong></em></p>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><ol>
<li><p>消除取值重复的行，这个需要用到distinct关键字，会把重复的元素给删除掉。这种情况一般用于查询学生人数什么的，跟多个属性挂钩的情况。如下例，查询选修了课程的学生的学号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno</span><br><span class="line"><span class="keyword">from</span> sc;</span><br></pre></td></tr></table></figure></li>
<li><p>查询满足条件的元组，通常使用where和比较运算符。</p>
</li>
<li><p>确定数据的范围，这个是使用的是between关键字，如下例，查询年龄在20-23岁(包括20和23)之间学生的姓名、系别、年龄：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> snake, sdept, sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sage <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>确定集合，这个是使用谓词IN，可以用来查找属性值属于制定集合的元组。</p>
</li>
<li><p>字符匹配，用的关键字是like，%是匹配任意长度的字符串，_是匹配任意单个字符。</p>
</li>
<li><p>对最后的结果进行排序，用的是order by语句，可以接一个或者多个属性列。asc是降序、desc是升序。</p>
</li>
<li><p>聚集函数，只需要注意，<strong>where子句是不能够用聚集函数作为条件表达式的。聚集函数只能用于select子句和group by中的having字句。</strong></p>
</li>
<li><p>group by子句，是讲查询结构按某一列或者多列的值分组，值相等的分为一组。分组后聚集函数讲作用于每一个组，即每一个组都有一个函数值，</p>
</li>
<li><p>相关子查询：如果子查询的条件依赖于父查询，这类子查询称为相关子查询。不相关子查询：子查询条件是不依赖于父查询的。</p>
</li>
<li><p>any和all</p>
<table>
<thead>
<tr>
<th></th>
<th>=</th>
<th>!=</th>
<th>&lt;</th>
<th>&lt;=</th>
<th>&gt;</th>
<th>&gt;=</th>
</tr>
</thead>
<tbody><tr>
<td>any</td>
<td>in</td>
<td>–</td>
<td>&lt;max</td>
<td>&lt;=max</td>
<td>&gt;min</td>
<td>&gt;=min</td>
</tr>
<tr>
<td>all</td>
<td>–</td>
<td>not in</td>
<td>&lt;min</td>
<td>&lt;=min</td>
<td>&gt;max</td>
<td>&gt;=max</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><blockquote>
<p>数据更细的操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。</p>
</blockquote>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ol>
<li>插入一个元组，基本语法：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[列名]</span><br><span class="line"><span class="keyword">values</span>(<span class="operator">&lt;</span>常量<span class="operator">&gt;</span>、...)</span><br></pre></td></tr></table></figure>
没什么具体要求，就是要注意字符串是单引号就行。</li>
<li>插入子查询(批量元素的插入)，类似于上述表达式，先执行子查询，然后把子查询的结果再插入到表中。</li>
</ol>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">set</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
<p>delete跟那个alter不一样，这个是删除的数据，而不是表的定义，注意区分开。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote>
<p>视图是从一个或者几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放数据的定义，而不存放视图对应的数据，这些数据任然被放在基本表中。一旦基本表发生改变，视图也会发生改变。就像是一个窗户，透过它可以看到数据中自己感兴趣的数据以及变化。</p>
</blockquote>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p>其一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span><span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>)...]</span><br><span class="line"><span class="keyword">as</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure>
<p>子查询可以是任意的select语句，是否可以含有order by子句和distinct短语由具体系统的实现。<br><em><strong>只是把视图的定义存入数据字典，并不执行其中的select语句</strong></em>。</p>
<p>行列子集视图：去掉了基本表其他的某些行和某些列，只保留了主码。<br>分组视图：带有聚集函数和group by子句的查询来定义视图。<br><em><strong>并不是所有视图都是可更新的</strong></em></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：关系数据库</title>
    <url>/2021/12/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="第二章：关系数据库"><a href="#第二章：关系数据库" class="headerlink" title="第二章：关系数据库"></a>第二章：关系数据库</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>略</p>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><blockquote>
<p>通常包括查询操作和修改操作两大部分。其中选择、投影、并、差、笛卡尔积是5种基本操作。</p>
</blockquote>
<span id="more"></span>

<h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><blockquote>
<p>关系模式中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</p>
</blockquote>
<ol>
<li>实体完整性：若属性A是基本关系R的主属性，则A不能取空值。</li>
<li>参照完整性：F是R的外码，它与基本关系S的主码$k_{s}$相对应，则R中的每个元组在F上的值必须满足：或者取空值(F的每个属性值均为空值)，或者等于S中某个云组的主码值。</li>
<li>用户定义的完整性：自己定义就行。</li>
</ol>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：绪论</title>
    <url>/2021/12/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><blockquote>
<p>简单弄清楚data、DB、DBMS、DBS之间的关系</p>
</blockquote>
<h2 id="数据库系统的特点-重点"><a href="#数据库系统的特点-重点" class="headerlink" title="数据库系统的特点(重点)"></a>数据库系统的特点(重点)</h2><ol>
<li>数据结构化：DBS实现整体数据的结构化，这是主要特征之一。所谓的整体是指数据库中的数据不再仅仅针对某个应用，而是面向整个整体。不仅数据内部是结构化的，而且整体也是结构化，数据之间具有联系。</li>
<li>数据的共享性高，冗余度低且易扩充。</li>
<li>数据独立性高：物理独立和逻辑独立。物理独立性是指用户的应用程序与数据库中的数据的物理存储是相互独立的。逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</li>
<li>数据由DBMS统一控制和管理。</li>
</ol>
<span id="more"></span>

<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h2><ol>
<li>概念模型：就是对现实的抽象，也叫做信息模型。</li>
<li>逻辑模型：主要分为层次模型、网状模型、关系模型等，主要是抽象出来给计算机系统建模使用。</li>
<li>物理模型：是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法。</li>
</ol>
<h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><h3 id="信息世界中的基本概念"><a href="#信息世界中的基本概念" class="headerlink" title="信息世界中的基本概念"></a>信息世界中的基本概念</h3><ol>
<li>实体：客观存在并可相互区别的事物称为实体。</li>
<li>属性：实体所具有的某一特性称为属性。</li>
<li><strong>码：唯一标识实体的属性集称为码(重点)。</strong></li>
<li>实体型：</li>
<li>实体集：</li>
<li>联系：联系有好多种。</li>
</ol>
<h2 id="数据模型的组成元素-重点"><a href="#数据模型的组成元素-重点" class="headerlink" title="数据模型的组成元素(重点)"></a>数据模型的组成元素(重点)</h2><blockquote>
<p>数据模型通常由数据结构、数据操作和数据的完整性约束三部分组成。</p>
</blockquote>
<ol>
<li>数据结构：描述数据库组成的对象以及对象之间的联系。</li>
<li>数据操作：分为查询和更新两大类。</li>
<li>数据的完整性约束条件：就是一组完整性规则，保证数据的正确、有效和相容。</li>
</ol>
<h2 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h2><blockquote>
<p>这里讲的数据模型都是逻辑上的，也就是用户眼中看见的。</p>
</blockquote>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ol>
<li>有且只有一个结点没有双亲结点，这个结点称为根结点。</li>
<li>根以外的结点有且只有一个双亲结点。</li>
</ol>
<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><ol>
<li>允许一个以上的结点无双亲。</li>
<li>一个结点可以有多于一个的双亲。</li>
</ol>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><blockquote>
<p>每个关系的数据结构是一张规范化的二维表。</p>
</blockquote>
<ol>
<li>关系：一个关系对应通常来说就是一张表。</li>
<li>元组：表中的一行就是一个元组。</li>
<li>属性：表中的一列就是一个属性。</li>
<li>码：表中的某个属性组，可以用来唯一确定一个元组。</li>
<li>域：一组具有相同数据类型的值的集合。</li>
<li>分量：元组中的一个属性值。</li>
</ol>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><blockquote>
<p>模式是相对稳定的，而实例是相对变动的。因为数据库中的数据是在不断更新的。模式反映的是数据的结构以及其联系，二实例反映的是数据库某一时刻的状态。</p>
</blockquote>
<h3 id="数据库系统的三级模式结构-重点"><a href="#数据库系统的三级模式结构-重点" class="headerlink" title="数据库系统的三级模式结构(重点)"></a>数据库系统的三级模式结构(重点)</h3><ol>
<li>模式：也称为逻辑模式，是全体数据的逻辑结构和特征的描述。</li>
<li>外模式：也称为子模式，或者用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</li>
<li>内模式：存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</li>
</ol>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
</search>
