<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>指针终结者</title>
    <url>/2021/12/05/%E6%8C%87%E9%92%88%E7%BB%88%E7%BB%93%E8%80%85/</url>
    <content><![CDATA[<h1 id="指针是什么"><a href="#指针是什么" class="headerlink" title="指针是什么"></a>指针是什么</h1><blockquote>
<p>在计算机科学中，指针是编译程序中的一个对象，利用地址，它的值直接指向存在电脑存储器中另一个地方的值，由于通过地址找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化称为”指针”。<u>意思是通过它能找到以它为地址大的内存单元</u></p>
</blockquote>
<span id="more"></span>

<h5 id="总的来说，指针就是一个变量，里面存着内存单元的地址-编号-，指针就是地址。（存放在指针中的值都被当成变量来处理）。"><a href="#总的来说，指针就是一个变量，里面存着内存单元的地址-编号-，指针就是地址。（存放在指针中的值都被当成变量来处理）。" class="headerlink" title="总的来说，指针就是一个变量，里面存着内存单元的地址(编号)，指针就是地址。（存放在指针中的值都被当成变量来处理）。"></a>总的来说，指针就是一个变量，里面存着内存单元的地址(编号)，指针就是地址。（存放在指针中的值都被当成变量来处理）。</h5><h5 id="那么问题是："><a href="#那么问题是：" class="headerlink" title="那么问题是："></a>那么问题是：</h5><ul>
<li>一个内存单元有多大？(一个字节)</li>
<li>如何编址？</li>
</ul>
<p>一个内存单元一个字节就够了，然后不同数据类型的数据存储就按照字节由低到高排就行。比如，浮点型8个字节，它就会使用8个连续的内存单元，然后第一个内存单元就是其地址。</p>
<p>经过研究发现，一个字节给一个对应的地址是比较合适的。</p>
<p>对于32位的机器，假如有32根地址线，那么假设每根地址线在寻址的是产生一个电信号正电或者负电(1或者0)，那么32根地址线产生的地址就会是32个全0到32个全1，也就是说一共会产生$2^{32}$个地址。</p>
<h5 id="这里我们就能明白"><a href="#这里我们就能明白" class="headerlink" title="这里我们就能明白"></a>这里我们就能明白</h5><ul>
<li>在32位的操作系统中，地址是32个0或者1组成的二进制序列，那地址就得使用4个字节的空间来存储，所以一个指针变量的大小就应该是4个字节</li>
<li>在64位的操作系统中，则是8个字节。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>指针是用来存放地址的，地址是唯一标识一块地址空间的。</li>
<li>指针的大小在32位系统中是4个字节，64位系统中是8个字节。</li>
</ul>
</blockquote>
<hr>
<h1 id="指针和指针类型"><a href="#指针和指针类型" class="headerlink" title="指针和指针类型"></a>指针和指针类型</h1><blockquote>
<p>通过上述可知(以32位为例)，所有类型的指针都是4个字节，那不禁有个问题：是不是可以用一个范型的指针来代替所有的指针就可以呢？</p>
</blockquote>
<p>通过代码验证可知，不同指针类型可以进行对指针的存储，但是会警告。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">int</span>* pa = &amp;a;</span><br><span class="line">*pa = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这个是运行结果是，a所有字节的值都变成了0，也就是44 33 22 11 变成了 00 00 00 00</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\\代码<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">int</span>* pc = &amp;a;</span><br><span class="line">*pc = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这个运行的结果就不一样了，44 33 22 11 变成了 00 33 22 11，也就只对数据a的其中一个字节进行了赋值操作。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>指针类型决定了指针进行解引用操作的时候，能够访问空间的大小。对指针解引用时候有多大的权限(能操作几个字符)。</p>
<ul>
<li>int* p; *p能够访问4个字节</li>
<li>char* p; *p能够访问1个字节</li>
<li>double* p; *p能够访问8个字节</li>
</ul>
</blockquote>
<h3 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针+-整数"></a>指针+-整数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;n;</span><br><span class="line"><span class="keyword">int</span>* pi = &amp;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>通过对代码的运行，我们可知，主要是地址的后两位的变化。pc的后两位是58，而pc+1则是59。对于pi来说，它的地址也是58，但是pi+1的结果则是5C。说明pc+1就是往后移动了一个字节，但是pi+1则就是往后移动了4个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际操作：将数组的所有元素都变成1，对比输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//int *p = arr;   //数组名-首元素的地址</span></span><br><span class="line">    <span class="keyword">char</span> *p = arr;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>指针的类型决定了指针向前或者向后走一步有多大(距离)。</p>
</blockquote>
<hr>
<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><blockquote>
<p>概念：野指针就是指针指向的位置是不可知的（随机的、不确定的、没有明确限制的）</p>
</blockquote>
<h3 id="野指针形成的原因"><a href="#野指针形成的原因" class="headerlink" title="野指针形成的原因"></a>野指针形成的原因</h3><ol>
<li>指针未初始化 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">//局部变量是指针未初始化，默认为随机值</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li>
<li>指针访问越界 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>指针指向的空间被释放</li>
</ol>
<h3 id="如何避免野指针"><a href="#如何避免野指针" class="headerlink" title="如何避免野指针"></a>如何避免野指针</h3><ol>
<li>指针初始化</li>
<li>小心指针越界</li>
<li>指针指向空间释放即使置NULL</li>
<li>指针使用之前要检查有效性</li>
</ol>
<hr>
<h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><ul>
<li>指针+-正数</li>
<li>指针-指针</li>
<li>指针的关系运算</li>
</ul>
<h3 id="指针-—整数"><a href="#指针-—整数" class="headerlink" title="指针+—整数"></a>指针+—整数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_VALUES 5</span></span><br><span class="line"><span class="keyword">float</span> values[N_VALUES];</span><br><span class="line"><span class="keyword">float</span> *vp;</span><br><span class="line"><span class="keyword">for</span>(vp=&amp;values[<span class="number">0</span>]; vp&lt;values[N_VALUES];)</span><br><span class="line">&#123;</span><br><span class="line">    *vp++ = <span class="number">0</span>; <span class="comment">//这个代码执行是，先*vp=0，然后在vp++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针-指针"></a>指针-指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用头尾指针的方法，尾指针-头指针=指针之间的长度</span></span><br><span class="line">    <span class="keyword">char</span>* start = str;</span><br><span class="line">    <span class="keyword">char</span>* end = str;</span><br><span class="line">    <span class="keyword">while</span>(*end != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = my_strlen(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="标准规定"><a href="#标准规定" class="headerlink" title="标准规定"></a>标准规定</h5><blockquote>
<p>允许指向数组元素的指针指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</p>
</blockquote>
<hr>
<h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h1><p>数组名是什么？我们看一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr)</span><br></pre></td></tr></table></figure>
<p>我们会发现得出来的结果都是一样的，但是他们的含义不一样。</p>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>&amp;arr &amp;数组名，表示取出来的是整个数组的地址。</li>
<li>sizeof(arr)，计算的是整个数组的大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>arr</td>
<td>00EFF8E0</td>
</tr>
<tr>
<td>arr+1</td>
<td>00EFF8E4</td>
</tr>
<tr>
<td>&amp;arr[0]</td>
<td>00EFF8E0</td>
</tr>
<tr>
<td>&amp;arr[0]+1</td>
<td>00EFF8E4</td>
</tr>
<tr>
<td>&amp;arr</td>
<td>00EFF8E0</td>
</tr>
<tr>
<td>&amp;arr+1</td>
<td>00EFF908</td>
</tr>
</tbody></table>
<p>我们通过输出地址可以看出，前两个的+1，都是+1一个元素的大小，但是&amp;arr+1加的则是整个数组的长度。16进制的28，其10进制结果则是40，也就是整个数组的长度。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>难点</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：绪论</title>
    <url>/2021/12/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><blockquote>
<p>简单弄清楚data、DB、DBMS、DBS之间的关系</p>
</blockquote>
<h2 id="数据库系统的特点-重点"><a href="#数据库系统的特点-重点" class="headerlink" title="数据库系统的特点(重点)"></a>数据库系统的特点(重点)</h2><ol>
<li>数据结构化：DBS实现整体数据的结构化，这是主要特征之一。所谓的整体是指数据库中的数据不再仅仅针对某个应用，而是面向整个整体。不仅数据内部是结构化的，而且整体也是结构化，数据之间具有联系。</li>
<li>数据的共享性高，冗余度低且易扩充。</li>
<li>数据独立性高：物理独立和逻辑独立。物理独立性是指用户的应用程序与数据库中的数据的物理存储是相互独立的。逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</li>
<li>数据由DBMS统一控制和管理。</li>
</ol>
<span id="more"></span>

<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h2><ol>
<li>概念模型：就是对现实的抽象，也叫做信息模型。</li>
<li>逻辑模型：主要分为层次模型、网状模型、关系模型等，主要是抽象出来给计算机系统建模使用。</li>
<li>物理模型：是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法。</li>
</ol>
<h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><h3 id="信息世界中的基本概念"><a href="#信息世界中的基本概念" class="headerlink" title="信息世界中的基本概念"></a>信息世界中的基本概念</h3><ol>
<li>实体：客观存在并可相互区别的事物称为实体。</li>
<li>属性：实体所具有的某一特性称为属性。</li>
<li><strong>码：唯一标识实体的属性集称为码(重点)。</strong></li>
<li>实体型：</li>
<li>实体集：</li>
<li>联系：联系有好多种。</li>
</ol>
<h2 id="数据模型的组成元素-重点"><a href="#数据模型的组成元素-重点" class="headerlink" title="数据模型的组成元素(重点)"></a>数据模型的组成元素(重点)</h2><blockquote>
<p>数据模型通常由数据结构、数据操作和数据的完整性约束三部分组成。</p>
</blockquote>
<ol>
<li>数据结构：描述数据库组成的对象以及对象之间的联系。</li>
<li>数据操作：分为查询和更新两大类。</li>
<li>数据的完整性约束条件：就是一组完整性规则，保证数据的正确、有效和相容。</li>
</ol>
<h2 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h2><blockquote>
<p>这里讲的数据模型都是逻辑上的，也就是用户眼中看见的。</p>
</blockquote>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ol>
<li>有且只有一个结点没有双亲结点，这个结点称为根结点。</li>
<li>根以外的结点有且只有一个双亲结点。</li>
</ol>
<h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><ol>
<li>允许一个以上的结点无双亲。</li>
<li>一个结点可以有多于一个的双亲。</li>
</ol>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><blockquote>
<p>每个关系的数据结构是一张规范化的二维表。</p>
</blockquote>
<ol>
<li>关系：一个关系对应通常来说就是一张表。</li>
<li>元组：表中的一行就是一个元组。</li>
<li>属性：表中的一列就是一个属性。</li>
<li>码：表中的某个属性组，可以用来唯一确定一个元组。</li>
<li>域：一组具有相同数据类型的值的集合。</li>
<li>分量：元组中的一个属性值。</li>
</ol>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><blockquote>
<p>模式是相对稳定的，而实例是相对变动的。因为数据库中的数据是在不断更新的。模式反映的是数据的结构以及其联系，二实例反映的是数据库某一时刻的状态。</p>
</blockquote>
<h3 id="数据库系统的三级模式结构-重点"><a href="#数据库系统的三级模式结构-重点" class="headerlink" title="数据库系统的三级模式结构(重点)"></a>数据库系统的三级模式结构(重点)</h3><ol>
<li>模式：也称为逻辑模式，是全体数据的逻辑结构和特征的描述。</li>
<li>外模式：也称为子模式，或者用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</li>
<li>内模式：存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</li>
</ol>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：关系数据库</title>
    <url>/2021/12/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="第二章：关系数据库"><a href="#第二章：关系数据库" class="headerlink" title="第二章：关系数据库"></a>第二章：关系数据库</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>略</p>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><blockquote>
<p>通常包括查询操作和修改操作两大部分。其中选择、投影、并、差、笛卡尔积是5种基本操作。</p>
</blockquote>
<span id="more"></span>

<h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><blockquote>
<p>关系模式中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</p>
</blockquote>
<ol>
<li>实体完整性：若属性A是基本关系R的主属性，则A不能取空值。</li>
<li>参照完整性：F是R的外码，它与基本关系S的主码$k_{s}$相对应，则R中的每个元组在F上的值必须满足：或者取空值(F的每个属性值均为空值)，或者等于S中某个云组的主码值。</li>
<li>用户定义的完整性：自己定义就行。</li>
</ol>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：关系数据库标准sql语句</title>
    <url>/2021/12/06/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86sql%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="SQL语言的功能概述"><a href="#SQL语言的功能概述" class="headerlink" title="SQL语言的功能概述"></a>SQL语言的功能概述</h1><hr>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><ol>
<li><strong>模式定义</strong>：在sql中，模式定义语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">authorization</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
 实际上就相当于定义了一个框架，然后再去这个框架里面进一步创建基本表、视图、定义授权等等。  </li>
<li><strong>模式删除</strong>：在sql中，模式删除语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="operator">&lt;</span>cascade<span class="operator">|</span>restrict<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
 <em><strong>注意：选择前者的话，就是说删除模式的同时，也把该模式中所有数据库对象全部删除。选择后者的话，如果该模式中已经定义了下属的数据对象，则就拒绝该操作，该模式没有任何下属的对象才可以删除。</strong></em></li>
</ol>
 <span id="more"></span>

<h3 id="基本表的定义、删除、与修改"><a href="#基本表的定义、删除、与修改" class="headerlink" title="基本表的定义、删除、与修改"></a>基本表的定义、删除、与修改</h3><ol>
<li><strong>表的定义</strong>：在sql中，表的定义语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[具体要求]</span><br></pre></td></tr></table></figure></li>
<li><strong>表的删除</strong>：在sql中，表的删除语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [cascade<span class="operator">|</span>restrict]</span><br></pre></td></tr></table></figure></li>
<li><strong>表的修改</strong>：在sql中，表中的修改语句如下： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[具体要求]</span><br></pre></td></tr></table></figure>
 <em><strong>注意：这些操作都是对表的属性什么的来操作，比如增加属性呀什么的，跟update处理数据要区分开。</strong></em></li>
</ol>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><blockquote>
<p>当表的数据量比较大的时候，查询会比较耗时，索引建立索引来帮助快速查询数据。</p>
</blockquote>
<hr>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>在sql中，数据查询的语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>目标或者表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名或者视图名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>条件表达式或者子查询<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">having</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：having与where作用的对象不同，having操作的对象是组，而where操作的对象是每一个元组。order by只能对最终结果排序。</strong></em></p>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><ol>
<li><p>消除取值重复的行，这个需要用到distinct关键字，会把重复的元素给删除掉。这种情况一般用于查询学生人数什么的，跟多个属性挂钩的情况。如下例，查询选修了课程的学生的学号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno</span><br><span class="line"><span class="keyword">from</span> sc;</span><br></pre></td></tr></table></figure></li>
<li><p>查询满足条件的元组，通常使用where和比较运算符。</p>
</li>
<li><p>确定数据的范围，这个是使用的是between关键字，如下例，查询年龄在20-23岁(包括20和23)之间学生的姓名、系别、年龄：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> snake, sdept, sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sage <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>确定集合，这个是使用谓词IN，可以用来查找属性值属于制定集合的元组。</p>
</li>
<li><p>字符匹配，用的关键字是like，%是匹配任意长度的字符串，_是匹配任意单个字符。</p>
</li>
<li><p>对最后的结果进行排序，用的是order by语句，可以接一个或者多个属性列。asc是降序、desc是升序。</p>
</li>
<li><p>聚集函数，只需要注意，<strong>where子句是不能够用聚集函数作为条件表达式的。聚集函数只能用于select子句和group by中的having字句。</strong></p>
</li>
<li><p>group by子句，是讲查询结构按某一列或者多列的值分组，值相等的分为一组。分组后聚集函数讲作用于每一个组，即每一个组都有一个函数值，</p>
</li>
<li><p>相关子查询：如果子查询的条件依赖于父查询，这类子查询称为相关子查询。不相关子查询：子查询条件是不依赖于父查询的。</p>
</li>
<li><p>any和all</p>
<table>
<thead>
<tr>
<th></th>
<th>=</th>
<th>!=</th>
<th>&lt;</th>
<th>&lt;=</th>
<th>&gt;</th>
<th>&gt;=</th>
</tr>
</thead>
<tbody><tr>
<td>any</td>
<td>in</td>
<td>–</td>
<td>&lt;max</td>
<td>&lt;=max</td>
<td>&gt;min</td>
<td>&gt;=min</td>
</tr>
<tr>
<td>all</td>
<td>–</td>
<td>not in</td>
<td>&lt;min</td>
<td>&lt;=min</td>
<td>&gt;max</td>
<td>&gt;=max</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><blockquote>
<p>数据更细的操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。</p>
</blockquote>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ol>
<li>插入一个元组，基本语法：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[列名]</span><br><span class="line"><span class="keyword">values</span>(<span class="operator">&lt;</span>常量<span class="operator">&gt;</span>、...)</span><br></pre></td></tr></table></figure>
没什么具体要求，就是要注意字符串是单引号就行。</li>
<li>插入子查询(批量元素的插入)，类似于上述表达式，先执行子查询，然后把子查询的结果再插入到表中。</li>
</ol>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">set</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span><span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除语句的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
<p>delete跟那个alter不一样，这个是删除的数据，而不是表的定义，注意区分开。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote>
<p>视图是从一个或者几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放数据的定义，而不存放视图对应的数据，这些数据任然被放在基本表中。一旦基本表发生改变，视图也会发生改变。就像是一个窗户，透过它可以看到数据中自己感兴趣的数据以及变化。</p>
</blockquote>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p>其一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span><span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>)...]</span><br><span class="line"><span class="keyword">as</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure>
<p>子查询可以是任意的select语句，是否可以含有order by子句和distinct短语由具体系统的实现。<br><em><strong>只是把视图的定义存入数据字典，并不执行其中的select语句</strong></em>。</p>
<p>行列子集视图：去掉了基本表其他的某些行和某些列，只保留了主码。<br>分组视图：带有聚集函数和group by子句的查询来定义视图。<br><em><strong>并不是所有视图都是可更新的</strong></em></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>sql语言</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
</search>
